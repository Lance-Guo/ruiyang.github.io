<?xml version="1.0" encoding="utf-8"?>
<search>
  
    
    <entry>
      <title><![CDATA[代码整洁之道学习笔记]]></title>
      <url>%2F2020%2F03%2F29%2F17.%E4%BB%A3%E7%A0%81%E6%95%B4%E6%B4%81%E4%B9%8B%E9%81%93%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2F</url>
      <content type="text"><![CDATA[代码整洁之道1.要有代码代码的整洁是非常重要的，很多时候我们不是在敲写代码，而是在试着读懂代码。糟糕的代码只能让人望而生畏，无从下手;而整洁的代码则会使我们轻松的了解代码书写者的意图以及代码所做的事。而大家对代码整洁有着不同的认知，不过整洁的代码一定是要减少重复，提高表达力，构建简单抽象。也可以说成：消除重复， 2.有意义的命名代码中命名的地方有很多，要给变量、函数、类、包、文件等等进行命名，取个好的名字能让我们一眼看出他的作用而不需要添加多余的注释好的名字有以下规则： 名副其实： 命名应该告诉我们他为什么存在，他做什么事，应该怎么用 避免误导： 避免留下掩藏带啊吗本意的错误线索 使用有意义的区分： 不能给命名添加数字系列和废话 使用读的出来的名称： 命名可以读出来，而不是全是单词缩写 使用可搜索的名称： 避免使用单字符名称 避免使用编码：不要把类型或作用域编进命名中 避免思维映射： 明确即是王道 类名： 类名和对象名一般是名词或名词短语 方法名： 方法名一般是动词或动词短语 别扮可爱： 避免使用俚语 每个概念对应一个词： 每个抽象概念选一个词并且一以贯之，不要出现control和manager这样表达一个概念用不同的单词的现象 别用双关语： 避免同一单词用于不同目的，同意术语用于不同概念 使用解决方案领域的名称： 尽量用计算机科学术语，算法名，模式名毕竟读你代码的也是程序员 使用源自所涉问题领域的名称： 当不能使用程序员所熟悉的术语时使用所涉问题领域的术语 添加有意义的语境，避免添加没用的语境 3. 函数我们以前的系统由程序和子程序构成，再后来系统由程序、子程序和函数构成，后来只有函数存活下来。函数是所有程序中的第一组代码，因此写好函数对我们程序员来讲尤为重要，好的函数一般有以下规则： 短小： 一个函数能够在20行封顶最佳 只做一件事： 函数应该做一件事，做好这件事，只做这件事。 每个函数一个抽象层级： 函数的语句要在统一抽象层级上 switch语句： 无法避免switch语句，但是要确保每个switch都隐藏在较低的抽象层级中，并且永远不重复 使用描述性的名称： 给你的函数取个好名字，让他深合己意 函数参数： 最理想的参数数量是0，其次是1个，再次是2，应尽量避免三个参数的函数 代码整洁之道 代码是我们必不可少的，整洁的代码就像讲好一个故事一样，让人能够跟着书写者的思路把一个“故事”了解透彻。好的代码能够提高我们对代码的修改和迁移的效率。果断决绝，就事论事，没有犹豫和不必要的细节这些都是整洁代码的体现。我们要做到减少重复代码，提高表达力，构建简单抽象等方面才能写出整洁的代码。整洁代码的体现有： 1. 你程序中的命名都是有意义的。你的类名应该是名词或者名词短语，你的方法名应该是动词或动词短语。好的命名是名副其实，不存在歧义的，他不是通过编码来区分彼此的。因此，你的命名要避免使用编码，每个命名都是可以读出来的。同样，在你的程序中尽量一个概念对应一个词，不要使用多个词来表述同一个概念。我们要尽量使用计算机领域所长使用的一些单词来进行命名，给你的命名加上一些特定的语境，让别人通过命名就大概知道你在做什么。2. 我们要尽可能的不去写注释，因为好的程序通过代码来告诉你他在做什么，而不是通过注释。最好的注释就是没有注释。在一些无法避免的情况下你可以写注释，比如提供法律信息，函数的返回值，对代码意图（代码本身不能体现其意义时）的解释，TODO注释，警示和放大一些不常规代码的使用意义。那些多余的，喃喃自语的，给人带来误导的，HTML注释，还有不是本地信息的，作为位置标记的，注释掉的代码等等这些坏的注释不要出现在代码中。3. 函数使我们程序的重要组成部分，而对JavaScript这样的函数式编程语言来讲，函数更加的重要，因此写好函数才能让我们的程序代码更加的健壮和可用。好的函数一定是只用来做一件事的短小的且只有一个抽象层级的代码段，在函数中尽量避免使用大量的if else语句。给你的函数起一个好名字，让你函数没有副作用，把错误处理从你的函数中抽离，尽量不要重复的去写同一个用处的函数，结构化编程。总的来讲写好一个函数不是一蹴而就的，我们要反复的推敲和斟酌自己所写的函数，使他尽量的短小，一目了然。4. 代码是有格式的，格式的好坏没有固定的评判标准。但是我们要尽量让自己的代码格式与主流的代码格式一样，当然如果在一个团队中，那么以团队所规定的的代码格式为标准来书写自己的代码。好的格式会让你的代码看起来整齐，赏心悦目，才让人有兴趣去了解你的代码在做些什么。5. 抽象和数据结构，我们都知道有两种编程思想，一种是面向过程变成（也就面向方法编程），一种是面向对象编程。在面向过程编程中我们使用的是数据结构，即在数据结构中我们暴露其数据，但是没有提供有意义的函数，然后外层写方法根据数据结构的类型来编写这个方法；而面向对象恰好相反，对象将数据隐藏在抽象之后，暴露操作数据的函数。总结来说，对象暴露行为，隐藏数据，它方便我们添加新的对象类型而无需修改既有行为，但同时也难以在既有对象中添加新的行为； 而数据结构暴露数据，没有操作数据的行为，它便于我们向既有数据结构中添加行为， 但同时难以向既有函数中添加新的数据结构。因此在编程是我们要看自己的业务需求来选择这两种编程思想中的一种。 德墨忒尔律： 模块不应该了解他所操作的对象的内部结构！6. 整洁的代码是将错误处理进行隔离对待，独立于我们代码的主要逻辑。为什么会产生错误，一方面是一种我们无法避免的情况：设备失效，网络错误等；一种是我们程序中代码所产生的错误，这类错误我们要尽量避免，比如不要写一些返回null值得函数，也不要在函数之间传递null值。好的错误处理应该使用异常处理而非返回码，因此在写可以产生错误的函数时，应该先写try-catch-finally 语句，同时尽量使用不可控异常处理方法，给我们的异常方法的环境进行说明，可以定义一些异常类对我们要写的异常处理方法进行封装。记住我们的目的是为了让错误处理不去搞乱我们的代码逻辑。7. 边界8. 测试]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Vue学习]]></title>
      <url>%2F2020%2F03%2F20%2F16.Vue%E5%AD%A6%E4%B9%A0%2F</url>
      <content type="text"><![CDATA[Vue的基本使用我们可以在Vue的官网进行Vue的学习，Vue是尤雨溪编写的，因此中文文档很详细。下边是链接链接： https://cn.vuejs.org/ 从Vue的官网我们可以看到Vue的定于：Vue (读音 /vjuː/，类似于 view) 是一套用于构建用户界面的渐进式框架。与其它大型框架不同的是，Vue 被设计为可以自底向上逐层应用。Vue 的核心库只关注视图层，不仅易于上手，还便于与第三方库或既有项目整合。另一方面，当与现代化的工具链以及各种支持类库结合使用时，Vue 也完全能够为复杂的单页应用提供驱动。 Vue的指令系统Vue的数据双向绑定]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[TypeScript]]></title>
      <url>%2F2020%2F03%2F13%2F14.TypeScript%2F</url>
      <content type="text"><![CDATA[TypeScript和JavaScriptTypeScript 是JavaScript 的一个超集，支持ES6标准TypeScript的实际目标是开发大型应用，他可以编译成纯的JavaScriptTypeScript增加的功能有： 类型批注和编译时类型检查 类型推断 接口 枚举 Mixin 泛型编程 名字空间 元组 Await 从ES6反移植来的：类、模块、lambda函数的箭头语法、可选参数和默认参数 TypeScript安装如果你想让自己的TS代码转化成JS代码，可以通过NPM来进行安装//全局安装typescript工具npm install -g typescript//将ts文件生成一个同名的js文件，放在同一目录下tec test.ts另外一种方法就是使用IDE,比如VSCode TypeScript的基础语法TS(TypeScript的简写)程序由模块、函数、变量、语句和表达式、注释等组成 TypeScript的一些语法特性 保留字： in break if try continue implements等等 TS会忽略程序中出现的空格、制表符和换行符 TS区分大小写 分号可选，但尽量不省略 TS注释：// 行注释 / 块注释 / TS是面向对象的，如下边的例子1234567class Site&#123; name(): void&#123; console.log(&quot;Me&quot;); &#125;&#125;var obj = new Site();obj.name(); TypeScript的基础类型 数据类型 关键字 描述 任意类型 any 声明为any的变量可以赋予任意类型的值 数字类型 number 双精度64为浮点数 字符串类型 string 使用’或者”来表示，反引号`来定义多行字符串和内嵌表达式 布尔类型 boolean true或false 数组类型 无 let arr: number[] 元组 无 let x: [string, number] 枚举 enum 枚举类型用于定义数值集合 void void 用于表示方法返回值的类型，表示该方法没有返回值 null null 表示对象值缺失 undefined undefined 初始化变量为一个未定义的值 never never never是其他类型包括null和undefined 这里着重说一下TS的``多行字符串，他还可以作为字符串模板使用，和对字符串模板进行拆分 多行字符串 1234var str = `aaabbbccc`; 对应JS的var str = &quot;aaa\nbbb\nccc&quot;; 字符串模板： 12var name = &quot;myName&quot;;console.log(`my name is $&#123;name&#125;`); 字符串模板拆分 123456789101112function test(templete, name, age)&#123; console.log(templete); console.log(name); console.log(age);&#125;var myName = &quot;Guoruiyang&quot;;var getAge = function()&#123; return 18;&#125;test`hello my name is $&#123;myName&#125;, i&apos;m $&#123;getAge()&#125;`//注意这里的test后没有() TypeScript的变量声明TS的变量的声明只是多了类型声明，其他同JS一样。如：1234var username:string = &quot;Guoruiyang&quot;;function test(): void&#123; //没有返回值&#125; TypeScript的运算符TS的运算符、条件语句、循环、Number、String、Array同JS无区别 TypeScript的函数TS的函数参数与JS不同 传入函数的参数可以指定类型 123var getAge(num: number)&#123; return num;&#125; 传入函数的参数可以指定默认值 123456789101112// 带默认值的参数放在必选参数的的后边function test(a:string, b:string, c:string = &quot;jojo&quot;)&#123; console.log(a); console.log(b); console.log(c);&#125;//输出xx\n yy\n zztest(&quot;xx&quot;, &quot;yy&quot;, &quot;zz&quot;);//输出xx\n yy\n jojotest(&quot;xx&quot;, &quot;yy&quot;);//报错test(&quot;xx&quot;); 可选参数 123456789101112//第二个参数是可选的，可选参数放在必选参数的的后边function test(a:string, b?:string, c:string = &quot;jojo&quot;)&#123; console.log(a); console.log(b); console.log(c);&#125;//输出xx\n yy\n zztest(&quot;xx&quot;, &quot;yy&quot;, &quot;zz&quot;);//输出xx\n yy\n jojotest(&quot;xx&quot;, &quot;yy&quot;);//输出xx\n undefine jojotest(&quot;xx&quot;); 函数新特性 Rest和Spread操作符 …可以传入函数任意数量的参数 1234567891011121314151617181920function func1(...args)&#123; args.forEach(function(arg)&#123; console.log(arg); &#125;)&#125;var args = [1,2,3];//输出1\n 2\n 3func1(args);function func2(a, b, c)&#123; console.log(a); console.log(b); console.log(c);&#125;var args = [1,2];//输出1\n 2\n undefinefunc1(...args);var args1 = [1, 2, 3, 4];//输出1\n 2\n 3\n func1(...args1); generator函数 控制函数的执行generator函数的声明和调用如下： 123456789101112//函数后边跟*表示是generator函数function* doThings()&#123; console.log(&quot;start&quot;); yield; console.log(&quot;end&quot;);&#125;//doThings不能直接调用var func1 = doThings;//输出startfunc1.next();//输出endfunxc1.next(); destructuring析构表达式通过destructuring表达式将对象或数组拆解成任意数量的变量 12345678910111213141516171819202122//返回一个对象function getStock()&#123; return &#123; code: &quot;IBM&quot;, price: 100, other: 123 &#125;&#125;// 等同于var a = getStock(); a.code=&quot;IBM&quot;; a.price=100;var &#123;code, price&#125; = getStock();//错误var &#123;codex, price&#125; = getStock();//正确 codex的值就是code的值var &#123;code: codex, price&#125; = getStock();var array1 = [1, 2, 3, 4, 5];//num1 = 1; num2 = 2var [num1. num2] = array1;//num1 = 3; num2 = 4var [,,num1,num2] = array1;//num1 = 1; args = [2, 3, 4, 5] var [num1, ...args] = array1; 箭头表达式通过=&gt; 箭头表达式来声明匿名函数，消除了传统匿名函数中this指针的问题 12345678910111213141516function getSockt(name:string)&#123; this.name = name; setInterval(function()&#123; console.log(&quot;my name is &quot; + this.name); &#125;, 1000);&#125;function getSockt2(name:string)&#123; this.name = name; setInterval(() =&gt; &#123; console.log(&quot;my name is &quot; + this.name); &#125;, 1000);&#125;//调用getSockt(&quot;IBM&quot;)函数输出my name is var stock = new getSockt(&quot;IBM&quot;);//调用getSockt2(&quot;IBM&quot;)函数输出my name is IBMvar stock2 = new getSockt2(&quot;IBM&quot;); TypeScript元组在我看来元组解释特殊的数组，元组里的数据类型可以不一样12345678var mytuple = [10,&quot;Runoob&quot;]; // 创建元组console.log(mytuple[0]) ; //10console.log(mytuple[1]); //Runoobmytuple[0] = 100;// 更新元组元素console.log(mytuple[0]) ; //100mytuple.push(12);//增加元组元素mytuple.pop();//12删除元素var [b, c] = mytuple;// b = 10, b= Runoob TypeScript联合类型联合类型就是给一个变量设置多种类型，通过|管道符来实现语法格式： Type1|type2|type3var valu:string|number;var arr: string[] | number[]; TypeScript接口学过面向对象的我们都知道接口，接口就是一系列抽象方法的声明TS的接口定义如下：interface interface_name{ } 接口实例，实现接口的属性和方法 接口继承， 接口用过其他接口来扩展自己，关键字是extends 单接口：Child_interface_name extends super_interface_name 多接口：Child_interface_name extends super_interface_name, super_interface1_name TypeScript类TS的类和其他卖你想对象的语言一样，描述了所创建的对象的公共的属性和方法定义方式如： class class_name { // 类作用域 }类的继承： 类可以继承其他类，类继承也是使用extends关键字子类除了不能继承父类的私有成员和构造函数，其他都可以继承。TS一次只能继承一个类，不支持继承多个类。但支持多重继承class child_name extends parent_name子类对父类方法的重写叫做方法的重写 类可以继承接口，继承接口使用implements关键字class class_name implements interface_name 类中属性方法的控制修饰符 static: 指定类的数据成员为静态的，静态成员可以直接通过类名来调用 public: 默认值，☞共有，可以在任何地方被访问 protected: 受保护的，可以在其自身以及其父类和子类访问 private: 私有，只能在其所定义的类访问 TypeScript命名空间、模块、声明文件 TS的命名空间TS的命名空间可以说是ES6的模块化，通过TS明明空间namespace来定义的代码会编译成基于闭包将局部变量暴露给外部，命名空间最好不要和模块一起混用。如： 1234567891011namespace MyMath&#123;//使用namespace 指令来申明命名空间MyMath //使用export指令将属性和方法暴露给域外部 export const PI = 3.14; export function sumValue(num1: number, num2: number)&#123; return num1 + num2; &#125;&#125;// 在外部使用命名空间MyMath.PI;MyMath.sunValue(2, 3); 模块TS对ES6和CommonJS两种模块系统都有很好的支持。可以沿用以前JS的写法我们默认一个文件就是一模块这里着重来说一下ES6模块系统和CommonJS模块系统的区别： CommonJS模块输出的是一个值的拷贝，ES6模块输出的是值的引用CommonJS模块是运行时加载，ES6模块是编译时输出接口两者的写法也不同： 12345678910111213141516171819202122//ES6导入//从module_a模块导入a和bimport &#123;a, b&#125; from &apos;./es6/module_a&apos;;//从module_a模块导入a,并重新起名为fimport &#123;a as f&#125; from &apos;./es6/module_a&apos;//从module_a模块导入所有对象并重新起名为Allimport * as All from &apos;./es6/module_a&apos;;//从module_a模块导入Objimport Obj from &apos;./es6/module_a&apos;;//ES6导出export defalut Obj;export &#123;a, b, c&#125;;export &#123;d as D&#125;;//ComonJS导入let c1 = require(&apos;./node/a.ts&apos;);let c2 = require(&apos;./node/b&apos;);//CommonJS导出module.exports = a;module.exports = &#123;&#125;; 从上边代码可以看出： 导出： ES6允许同时存在export default和export多个变量，而CommonJS只允许有一种形式的导出，其中一种会把另外一种覆盖掉。 导入： ES6可以按需导入也可以全部导入，而CommonJS只能全部导入。ES6是未来的模块化标准，而且可以按需导入，是未来的发展方向。 声明文件声明文件以.d.ts为后缀runoob.d.ts声明文件和模块的语法declare module Module_Name{ }导入声明文件语法：/// 可以看出声明文件也是模块化的一种方式，基本不使用 总结感谢你读到了这里，如果你把这边介绍读完，基本上你就会使用TypeScript语法了。那就在开发中使用他吧。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[WebPack]]></title>
      <url>%2F2020%2F03%2F13%2F15.WebPack%2F</url>
      <content type="text"><![CDATA[webpack是一个打包工具，可以将JS，CSS， image等资源当成一个个模块进行打包。打包的好处有： 减少了页面的衍生请求次数，提高网站效率 将ES6等高级语法进行转化编译，以兼容浏览器 打包的同时将代码混淆，提高代码安全性 webpack 的核心都写在他的配置文件webpack.config.js中，具体的属性有 入口：entry: 打包的起点，一个或者多个。一般是一个js文件，从该文件寻找依赖 输出： outpur: 一个对象，包含两个属性: path: 打包的目标文件夹；filename: 打包后的文件名称 加载器：Loader: webpack本身只能识别js文件，如果要加载非js文件我们需要只当额外的加载器，常用的有babel转码器可以将ES6,ES7,JSX,等高级语法转化为浏览器支持的ES5。loader的配置项（写在rules[]中）有: test: 必须项，以匹配loaders所处理文件的扩展名的正则表达式loader: 必须项，loader的名称，一般放到use对象中include/exclude: 可选项，手动添加必须处理或者不处理的文件夹。query: 可选项，为loader提供额外的设置选项 插件： plugins：数组可选项，为webpack添加插件一个完整的webpack.config.js如下12345678910111213141516171819202122232425262728293031323334353637modudle.export = &#123; mode: &quot;development&quot;, devtool: &apos;eval-source-map&apos;, devServer: &#123; contentBase: &quot;./common&quot;, historyApiFallback: true, inline: true &#125;, entry: __dirname + &quot;/app/main.js&quot;, output: &#123; path: __dirname + &quot;/common&quot;, filename: &quot;index.js&quot; &#125;, module: &#123; rules: [ &#123; test: /(\.jsx|\.js)$/, use: &#123; loader: &quot;babel-loader&quot;, &#125;, exclude: /node_modules/ &#125;, &#123; test: /\.css$/, exclude: /node_modules/, use: [ &#123; loader: &quot;style-loader&quot; &#125;, &#123; loader: &quot;css-loader&quot; &#125; ] &#125; ] &#125;&#125; 当然最好的做法就是自己设置一个webpack打包的项目，大家可以根据下边的链接一步一步实现以下： 转载和借鉴：作者：秉持本心链接：https://www.jianshu.com/p/1192cfd4a012]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[常见排序算法的JS实现]]></title>
      <url>%2F2017%2F08%2F16%2F9.%E5%B8%B8%E8%A7%81%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E7%9A%84JS%E5%AE%9E%E7%8E%B0%2F</url>
      <content type="text"><![CDATA[常见的排序算法常见排序算法的时间复杂度和空间复杂度1.算法的效率算法的效率主要由时间复杂率和空间复杂率来评估： 时间复杂度：程序运行所需的时间，可以看出程序对处理器的实用程度 空间复杂度：程序执行过程中所需的存储空间，可以看出程序对计算机内存的使用程度##### 1. 冒泡排序，原理： 一次比较相邻的两个数， 如果前边的大就交换位置，这样一轮下来，最后一个是最大的。 对除了最后一个数重复第一步，直到只剩一个数展开查看代码System.out.println(“Hello to see U!”);代码实现：12345678910111213141516171819202122function bubbleSort(myArray)&#123; var len = myArray.length; for (let i = 0; i &lt; len-1; i++) &#123; for(let j = 0, stop = len - i - 1; j &lt; stop; j++) &#123; if(myArray[j] &gt; myArray[j+1]) &#123; let temp = myArray[j]; myArray[j] = myArray[j+1]; myArray[j+1] = temp; &#125; &#125; &#125; return myArray;&#125;var s = [5,6,7,34,45,23,12,34,14,56];for (let i = 0; i &lt; 10; i++) &#123; s = s.concat(s); // 产生一个长度为2的九次方*10的数组&#125;var start = Date.now();bubbleSort(s);var end = Date.now();console.log(&quot;排序后的数组：&quot; + s);console.log(&quot;所用时间：&quot; + (end - start)); 2. 选择排序， 原理： 找出最小的数很第一个交换位置 在剩下的数中，找出第二小的数，放在第二个位置 依次类推代码实现：123456789101112131415161718192021function selectSort(myArray) &#123; var len = myArray.length; for (let i = 0; i &lt; len - 1; i++) &#123; for(let j = i+1; j &lt; len; j++) &#123; if(myArray[j] &lt; myArray[i]) &#123; temp = myArray[i]; myArray[i] = myArray[j]; myArray[j] = temp; &#125; &#125; &#125;&#125;var s = [5,6,7,34,45,23,12,34,14,56];for (let i = 0; i &lt; 10; i++) &#123; s = s.concat(s); // 产生一个长度为2的九次方*10的数组&#125;var start = Date.now();selectSort(s);var end = Date.now();console.log(&quot;排序后的数组：&quot; + s);console.log(&quot;所用时间：&quot; + (end - start)); 看到这里是不是觉得这个测试用例好蠢 我们改进一下：1234567891011function testTime(sortFunc) &#123; var s = [5,6,7,34,45,23,12,34,14,56]; for (let i = 0; i &lt; 10; i++) &#123; s = s.concat(s); // 产生一个长度为2的九次方*10的数组 &#125; var start = Date.now(); sortFunc(s); var end = Date.now(); console.log(&quot;排序后的数组：&quot; + s); console.log(&quot;所用时间：&quot; + (end - start));&#125; 之后写好一个方法，然后调用testTime()将排序方法传进去即可 插入排序 原理： 把数组分为已排序和未排序两部分。（第一步可以第一个数为已排序，其余为未排序） 从未排序中抽出第一个数，和已排序部分进行比较，插入到合适的位置代码实现：12345678910111213function insertionSort(myArray) &#123; var len = myArray.length; for (let i = 1; i &lt; len; i++) &#123; let k; for (let j = 0; j &lt; i; j++) &#123; if(myArray[i] &lt; myArray[j]) &#123; myArray[j+1] = myArray[j]; &#125; &#125; myArray[j] = myArray[i];s &#125; return myArray;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[JS高级程序设计学习笔记]]></title>
      <url>%2F2017%2F08%2F15%2F12.JS%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A14%E3%80%815%E7%AB%A0%2F</url>
      <content type="text"><![CDATA[第四章两种不同数据类型的值： 基本类型值， 引用类型值基本类型值： Undefined, Null, Boolean, Number, String基本类型值在内存中占据固定大小的空间， 因此保存在栈内存中引用类型的值是对象， 保存在堆内存中 动态的属性：定义和创建接不类型值和引用类型值的方式类似: 创建一个变量并为该变量赋值只能给引用类型值动态的添加属性方法，以便将来使用 复制变量值 从一个变量向两一个变量复制基本类型值：相当于创建了一个新的值并且赋值给变量对象， 创建值的一个副本 引用类型值的赋值： 是复制了一个指针，把指针的值赋给新的变量对象 传递参数 ECMAScript中所有函数的参数都是值传递的 检测类型基本类型值的检测： typeof() 检测对象是否是字符串(string)，数值(number)， 布尔值(boolean)， 还是undefined，对于引用类型统一返回object引用类型值的检测： instanceof 语法： result = variable instanceof constructor, 在检测一个引用类型值变量跟Object构造函数时始终返回true，基本类型返回false 执行环境及作用域执行环境执行环境（环境）定义了变量或函数有权访问的其他数据，决定了他们的各自的行为。每个执行环境都有一个与之关联的变量对象，环境中定义的变量和函数都保存在这个对象中。决定了变量的生命周期 全局执行环境： 全局执行环境是最外层的执行环境 函数执行环境： 每个函数都有自己的执行环境，环境栈 作用域链当代码在一个环境中执行时，会创建变量对象的一个作用域链。环境是函数时， 活动对象（arguments）作为变量对象内部环境可以通过作用域链访问所有外部环境，但外部环境不能访问内部环境的任何变量和函数。作用域链延长：1. try-catch语句的catch, 2. with语句 没有块级作用域 声明变量： 使用var声明的变量会自动添加到最接近的环境，如果在函数中，最近的环境就是函数的局部环境。如果没有用var 声明，该变量会自动添加到全局环境（严格模式行不允许这样）。 查询标识符： 搜索从作用域前端开始， 向上逐级查询与给定标识符匹配的字符串。同名标识符局部环境的会瓶坯父环境中的标识符 垃圾回收 标记清楚 引用计数 性能问题 管理内存 解除引用： 将一个对象值设置为null，作用是让其脱离执行环境，以便垃圾收集器下次将他回收。 第五章 引用类型引用类型值（对象）是引用类型的一个实例： 对象是某个特定引用类型的实例， 新对象使用new操作符后跟一个构造函数来创建的。构造函数本身就是一个函数，只是出于创建新对象的目的定义的。 Object类型 两种创建方式： new 操作符后跟Object构造函数 123var person = new Object();person.name = &quot;nico&quot;;person.age = 29; 对象字面量表示法： 1234var person = &#123; name: &quot;nico&quot;, age: 29&#125;; 对象属性的访问： 点表示法，如：person.age; 方括号表示法： 如： person[“name”]; Array 两种创建方式： new 加Array构造函数 123var colors = new Array();var colors1 = new Array(3); // 创建一个包含三项的数组var name = new Array(&quot;Grey&quot;); // 创建一个包含一项的数组 数组字面量法： 123var colors = [&quot;red&quot;, &quot;blue&quot;];var names = []; // 空数组var values = [1, 2,]; // 不要这样这样会创建一个2项或者三项的数组 数组读取： 读取和设置数组的值时， 使用方括号和基于0的数字索引： colors[1] = “black”;数组的length, 不止可读，也可以进行设置 检测数组 value instanceof Array 有局限性： 只能用于单一的全局执行环境 Array.isArray(value) (ECMAScript5 新增) 转换方法每个对象都有toLocaleString(), toString(), valueOf()方法数组继承的这三个方法，在默认情况下都会以逗号分隔的字符串形式返回数组项join()方法可以使用不同的分隔符来构建这个字符串 colors.join(“||”);如果数组的某一项值时null或者undefined，那么在返回的结果中以空字符串表示 栈方法栈是一种LIFO(Last-In-First-Out)后进先出的数据结构，栈的插入（推入）和移除（弹出）只发生在栈顶ECMAScript为数组提供了push(), pop()来实现栈方法 队列方法队列数据结构访问规则：FIFO(First-In-First-Out)先进先出，队列在队尾添加项， 在队头移除项通过push(), shift()来实现队列方法通过unshift(), pop()来反向模拟队列 重排序方法reverse()反转数组项的顺序sort()给数组排序，默认按升序排序数组, 默认是比较字符串，将数组每一项都转化成字符串然后比较sort()可以接受一个比较函数，比较函数接受两个参数，如果第一个参数应该在第二个参数之前就返回一个负数，相等返回0，第一个参数应该位于第二个参数之后返回1。 操作方法concat() 拼接数组，原数组不变，生成一个拼接后的数组slice() 基于当前数组的一项或者多项创建一个数组，相当于截取数组，接受两个参数：返回项的起始位置和结束位置，第二个参数省略的话就是默认数组结尾，有参数的话不包含结束位置的这一项splice() 最强的数组操作方法，可用于： 删除： 两个参数，要删除的第一项的位置和删除的项数 插入： 三个参数，起始位置，0（表示不删除）， 要插入的项 替换： 三个参数，起始位置， 要删除的项数， 插入的项 位置方法indexOf(): 从数组的开头向后查找lastIndexOf(): 从数组的末尾向前查找上边两个方法有两个参数： 要查找的项，（可选的）表示查找起点位置的索引 迭代方法ECMAScript5为数组定义了5个迭代方法，每个方法接受两个参数： 要在每一项上运行的函数， （可选的）运行该函数的作用域对象而这个作为参数的函数一般有三个参数，数组项的值，该项在数组的位置和数组对象本身 every(): 对数组中每一项运行给定函数，如果该函数对每一项都返回true，则返回true filter(): 对数组中每一项运行给定函数，返回该函数能够返回true的项构成的数组 forEach(): 对数组中每一项运行给定函数, 没有返回值 map(): 对数组中每一项运行给定函数, 返回每次函数调用结果组成的数组 some(): 对数组中每一项运行给定函数, 如果有一项该函数返回true就返回true12345var numbers = [1, 2, 3, 4];var result = numbers.map(function(item, index, array)&#123; return item * 2;&#125;);alert(result); // [2, 4, 6, 8] 缩小方法reduce()和reduceRight()这两个方法都会迭代数组所有项，然后构建一个最终返回的值。reduce()是从数组第一项开始遍历到最后reduceRight()是从数组最后一项开始遍历到第一项都接受两个参数： 在每一项上调用的函数， （可选的）作为缩小基础的初始值传入的第一个参数的函数接受四个参数： 前一个值，当前值，想的索引和数组对象。这个函数返回的任何值会作为第一个参数自动传给下一项。第一次迭代是发生在数组的第二项上，因此第一个参数是数组第一项，第二个参数是数组第二项 如：123456789var values = [1, 2, 3, 4];var sum = values.reduce(function(prev, cur, index, array)&#123; return prev + cur;&#125;); // ((1+2) + 3) + 4var sum2 = values.reduceRight(function(prev, cur, index, array)&#123; return prev + cur;&#125;); // ((4+3) + 2) + 1alert(sum); // 10alert(sum1); // 10 方法 作用 返回值 push() 在数组末尾添加项 修改后的数组长度 pop() 从数组末尾移除最后一项 移除的项 shift() 移除数组中的第一项 移除的项 unshift() 在数组前端添加项 修改后的数组长度 reverse() 反转数组项的顺序 反序后的数组 sort() 数组排序 排序后的数组 concat() 数组拼接 拼接后的数组 slice() 数组截取 截取后的数组 splice() 数组插入，删除，替换 操作后的数组 indexOf() 从前往后查找位置 项所在的索引 lastIndexOf() 从后往前查找位置 项所在的索引 Date类型创建日期对象： var now = new Date(); 没有参数时，新创建的对象自动获得当前时间如果根据日期和时间来创建日期对象，必须传入该日期的毫秒数，不方便为了简化提供了一个方法： Date.parse()将日期转化为毫秒数; 其实Date()在后台自动调用Date.parse();12var someDate = new Date(Date.parse(&quot;May, 25, 2004&quot;));var someDate1 = new Date(&quot;May, 25, 2004&quot;); // 这两个相同 Date.UTC()方法也同样返回表示日期的毫秒数，Date.UTC()的参数分别是年数， 基于0的月份， 月中的某一天， 小时数（0-23）， 分钟， 秒以及毫秒如：12var y2K = new Date(Date.UTC(2000,0)); // 2000年1月1日午夜零时var other = new Date(Date.UTC(2005, 4, 5, 17, 55, 55)); // 2005年5月5日下午5:55:55 Date.now()方法返回表示调用这个方法时的日期和时间的毫秒数 RegExp 类型var exp = / pattrn / flags; flags g 表示全局匹配 i 表示忽略大小写 m 表示多行匹配| 表示 | 含义 || :—– | :—– || \d | 匹配一个数字 || \w | 匹配一个字符或者数字 || . | 匹配任意一个字符 || * | 任意个字符（包括0个） || + | 表示至少一个字符 || ? | 表示0个或者一个字符 || {n} | 表示n个字符 || {n,m} | 表示n-m个字符 || \s | 匹配一个空格（包括Tab等空格符） || A|B | 表示n-m个字符 || ^ | 表示行的开头(^\d 表示以数字开头) || $ | 表示行的结束(\d$ 表示以数字结尾) || [] | 表示范围 [0-9a-zA-Z_]可以匹配一个数字字符或者下划线 | Function 类型 两种定义方式 函数声明语法定义： 123function sum (num1, num2) &#123; return num1 + num2;&#125; 函数表达式定义： 123var sun = function (num1, num2) &#123; return num1 + num2;&#125;; 区别：解析器会执行一个函数声明提升的过程（function declaration hoisting） 没有函数重载 函数内部属性 arguments： 包含传入函数的参数arguments对象有一个callee的属性，改属性是一个指针指向拥有这个arguments的函数（在严格模式下会出错）一个阶乘函数： 12345678910111213141516171819202122232425262728293031323334function factorial(num) &#123; if(num &lt;= 1) &#123; return 1; &#125; else &#123; return num * factorial(num - 1); &#125;&#125; // 缺点： 函数的执行和函数名factorial紧紧耦合在一起---function factorial(num) &#123; if(num &lt;= 1) &#123; return 1; &#125; else &#123; return num * arguments.callee(num - 1); &#125;&#125; // 缺点： 严格模式下arguments.callee会出错---function factorial() &#123; return (function f(num)&#123; if (num &lt;= 1) &#123; return 1; &#125; else &#123; return num * f(num -1) &#125; &#125;);&#125; // 缺点： 调用方法比较繁琐：factorial()(num);console.log(factorial()(5));---var factorial = (function f(num) &#123; if (num &lt;= 1) &#123; return 1; &#125; else &#123; return num * f(num -1) &#125;&#125;); // 完美 this: 引用的是函数数据执行的环境对象 函数对象的另一个属性caller： 保存着调用当前函数的函数的引用 函数方法和属性 函数是对象，因此函数也有属性和方法， 每个函数都包含的属性： length: 表示函数希望接受的命名参数的个数 prototype: 保存引用类型所有的实例方法的真正所在(prototype属性不可枚举) 每个函数都有两个非继承而来的方法：这两个方法都是在特定的作用域下运行函数，实际上就是设置函数内this的值，都接收两个参数 apply(): 参数：函数在其中运行的作用域， 另一个是参数数组（可以是Array的实例，也可以是arguments对象） call(): 参数：函数在其中运行的作用域， 另一个是参数（将参数逐个罗列出来）ECMAScript还定义了一个bind()方法 这个方法会创建一个函数的实例，其this值会被绑定传给bind()函数的值 基本包装类型基本包装类型是Number, Boolean, String；尽量不要显式的调用这三个来创建基本包装类型对象声明一个基本类型的数字值，布尔值，字符串时调用方法和添加属性时会进行一下步骤： 创建基本包装类型的一个实例 在实例上调用指定方法 销毁实例 Number类型：方法 | 返回值 | -:toString() | 方法可以接受一个表示基数的参数，返回一个几进制的数值的字符串表示valueOf() | 返回对象表示的基本类型的数值toFixed() | 方法会按照指定小数点位数返回数值的字符串表示toExponential() | 返回数值的指数表示法的字符串形式toPrecision() | 传入参数表示几位有效数字 String 类型： 字符方法 charAt(), charCodeAt() 操作方法：拼接：concat(), 截取：slice(), substr(), substring() 位置方法: indexOf(), lastIndexOf() trim()方法方法 | 返回值| — | —: || charAt() | 方法接受一个表示位置的参数，返回一个该位置的字符的字符串表示 |charCodeAt() | 方法接受一个表示位置的参数，返回一个该位置的字符的字符编码cancat() | 拼接后的字符串slice() | 参数1指定子字符串的开始位置，参数2子字符串到哪结束substr() | 参数1指定子字符串的开始位置，参数2子字符串的长度substring() | 参数1指定子字符串的开始位置，参数2子字符串到哪结束subStr() | 传入参数表示几位有效数字]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[面试总结]]></title>
      <url>%2F2017%2F08%2F13%2F11.%E9%9D%A2%E8%AF%95%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93%2F</url>
      <content type="text"><![CDATA[雅虎34条页面优化法则 尽量减少HTTP的请求次数： 合并文件，CSS Sprites, 图片地图， 内联图像 减少DNS查找次数 避免跳转 可缓存的AJAX 推迟加载内容 预加载 减少DOM元素数量 根据域名划分页面内容 使iframe的数量最小 不要出现404 使用内容分发网站 为文件头指定EXpirse或Cache-control Gzip压缩文件内容 配置Etag 尽早刷新输出缓冲 使用GET完后AJAX请求 吧样式表置于顶部 避免使用CSS表达式 使用外部JS和CSS 消减JS和CSS 用 代替@import 避免使用滤镜 将脚本置于页面底部 删除重复脚本 减少DOM访问 开发智能事件处理程序 减少Cookie体积 对于页面内容使用无Cookie域名 优化图像 优化CSS sprite 不要子啊HTML中缩放图像 favicon.ico要小且可缓存 保持单个内容小于25K 打包组件成复合文本 从输入URL到页面加载完后经历了什么 浏览器接受URL， URL的信息包括： 协议， 网络地址：端口号， 资源路径， 查询字符串？， 片段标识符# 将URL与缓存进行对比，如果请求页面在缓存中且未过期，直接进行第八步缓存分为彻底缓存和协商缓存，这里的是否过期指定是彻底缓存 - 彻底缓存的机制HTTP首部字段： cache-control Expires Expires是一个绝对事件即服务器时间（现已很少用） cache-control中的max-age 保存一个相对时间，如Cache-Control: max-age = 48420, 表示缓存在48420s内有效cache-control还有其他指令： cache-control还有其他指令： （ 请求/响应指令） no-cache,使用缓存前必须和服务器进行确认，也就是需要发起请求。 no-store,不缓存； （响应指令） public，缓存文件保存在缓存服务器上，且其他用户也可以访问； private，只有特定用户才能访问该缓存资源。 - 缓存协商当缓存过期时， 浏览器会向服务器发起请求询问资源是否真的过期这就是缓存协商HTTP首部字段： last-modified Etag last-modified是第一次请求资源时， 服务器返回的字段，表示最后一次更新的时间。下一次浏览器请求资源时就发送if-modified-since字段。服务器用本地Last-modified时间与if-modified-since时间比较，如果不一致则认为缓存已过期并返回新资源给浏览器；如果时间一致则发送304状态码，让浏览器继续使用缓存。当然，用该方法也存在问题，比如修改时间有变化但实际内容没有变化，而服务器却再次将资源发送给浏览器。所以，使用Etag进行判断更好。 Etag 资源的实体标识（哈希字符串），当资源内容更新时，Etag会改变。服务器会判断Etag是否发生变化，如果变化则返回新资源，否则返回304。 缓存协商的过程需要发起一起HTTP请求，如果返回304则继续使用缓存。对于移动端一次请求还是有代价的，所以我们需要避免304。对于很少进行更改的静态文件，可以在文件名中加入版本号，如get.v1.js，并且把Cache-Control的max-age设置成一年半载，这样就不会发送请求。需要注意的是，当这些文件更新的时候，我们需要更新其版本号，这样浏览器才会到服务器下载新资源。 DNS解析：网络地址不是IP地址，通过DNS解析域名返回一个IP地址3.1 DNS协议： DNS数据库是域名和IP地址相互映射的一个分布式数据库，DNS协议用来将域名转换为IP地址，它运行在UDP协议之上。为什么选择UDP而非TCP？原因如下：UDP无需连接，时效性更好，进行一次查询只需要两个DNS包。而TCP需要先用3个包建立连接，再用2个DNS包进行查询，最后用4个包断开连接，连接成本远大于查询本身，容易让DNS服务器不堪重负。3.2 DNS查询： 操作系统会先检查本地hosts文件是否有这个网址映射关系，如果有就调用这个IP地址映射，完成域名解析。 否则，查找本地DNS解析器缓存，如果查找到则返回。 否则，查找本地DNS服务器，如果查找到则返回。 否则，1）未用转发模式，按根域服务器 -&gt;顶级域,.com-&gt;第二层域，example.com -&gt;子域，www.example.com的顺序找到IP地址。2）用转发模式，按上一级DNS服务器-&gt;上上级-&gt;….逐级向上查询找到IP地址。 浏览器和服务器通过三次握手建立TCP链接 浏览器向服务器发送HTTP请求 服务器接收到请求，从它的文档空间中查找资源并饭会HTTP响应 浏览器接受HTTP响应，根据HTTP header里的状态码，做出处理1XX 表示消息2XX 表示成功3XX 表示重定向4XX 表示请求错误5XX 表示服务器端错误常见状态码：200 OK表示请求成功 一切正常301 Moved Permanently重定向，客户请求的文档在其他地方，新的URL在Location头中给出，浏览器应该自动地访问新的URL302 Found临时重定向，类似于301，但新的URL应该被视为临时性的替代，而不是永久性的。304 Not Modified客户端有缓冲的文档并发出了一个条件性的请求。服务器告诉客户，原来缓冲的文档还可以继续使用。400 Bad Request请求出现语法错误。403 Forbidden资源不可用。404 Not Found无法找到指定位置的资源。405 Method Not Allowed请求方法（GET、POST、HEAD、Delete、PUT、TRACE等）对指定的资源不适用。500 Internal Server Error服务器遇到了意料不到的情况，不能完成客户的请求。501 Not Implemented服务器不支持实现请求所需要的功能。 如果是可以缓存的，这个响应则会被存储起来。 解码9.1 浏览器拿到index.html文件后，就开始解析其中的html代码，遇到js/css/image等静态资源时，就向服务器端去请求下载9.2 解析成对应的树形数据结构DOM树、CSS规则树，Javascript脚本通过DOM API和CSSOM API来操作DOM树、CSS规则树。 渲染10.1 计算CSS样式（JS可动态修改dom或css,进一步改变渲染树和分布）10.2 构建渲染树（Repaint：屏幕的一部分要重画，比如某个CSS的背景色变了，元素的几何尺寸没有变。Reflow：几何尺寸变了，我们需要重新验证并计算Render Tree。）10.3 确认布局（定位坐标和大小，是否换行，各种position, overflow, z-index属性 ……）10.4 绘制（调用操作系统Native GUI的API绘制，将每个节点转化为实际像素绘制到视口上） 关闭TCP链接或者继续保持连接通过四次挥手关闭连接(FIN ACK, ACK, FIN ACK, ACK)。 百度面试注重基础 extend是继承，如何自己用原生JS实现继承 =&gt;函数与普通匿名函数的区别（this） CSS选择器的权重 转载和借鉴：作者：minxuan链接：http://www.jianshu.com/p/71cf7f69eca8]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[JS 字符串操作]]></title>
      <url>%2F2017%2F08%2F12%2F8.JS%20%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%93%8D%E4%BD%9C%2F</url>
      <content type="text"><![CDATA[JS自带函数1. concat将两个或多个字符的文本组合起来，返回一个新的字符串。var a = “hello”;var b = “,world”;var c = a.concat(b);alert(c);//c = “hello,world” 2. indexOf返回字符串中一个子串第一处出现的索引（从左到右搜索）。如果没有匹配项，返回 -1 。var index1 = a.indexOf(“l”);//index1 = 2var index2 = a.indexOf(“l”,3);//index2 = 3 3. charAt返回指定位置的字符。var get_char = a.charAt(0);//get_char = “h” 4. lastIndexOf返回字符串中一个子串最后一处出现的索引（从右到左搜索），如果没有匹配项，返回 -1 。var index1 = lastIndexOf(‘l’);//index1 = 3var index2 = lastIndexOf(‘l’,2)//index2 = 2 5. match检查一个字符串匹配一个正则表达式内容，如果么有匹配返回 null。var re = new RegExp(/^\w+$/);var is_alpha1 = a.match(re);//is_alpha1 = “hello”var is_alpha2 = b.match(re);//is_alpha2 = null 6. substring返回字符串的一个子串，传入参数是起始位置和结束位置。var sub_string1 = a.substring(1);//sub_string1 = “ello”var sub_string2 = a.substring(1,4);//sub_string2 = “ell” 7. substr返回字符串的一个子串，传入参数是起始位置和长度var sub_string1 = a.substr(1);//sub_string1 = “ello”var sub_string2 = a.substr(1,4);//sub_string2 = “ello” 8. replace用来查找匹配一个正则表达式的字符串，然后使用新字符串代替匹配的字符串。var result1 = a.replace(re,”Hello”);//result1 = “Hello”var result2 = b.replace(re,”Hello”);//result2 = “,world” 9. search执行一个正则表达式匹配查找。如果查找成功，返回字符串中匹配的索引值。否则返回 -1 。var index1 = a.search(re);//index1 = 0var index2 = b.search(re);//index2 = -1 10. slice提取字符串的一部分，并返回一个新字符串（与 substring 相同）。var sub_string1 = a.slice(1);//sub_string1 = “ello”var sub_string2 = a.slice(1,4);//sub_string2 = “ell” 11. split通过将字符串划分成子串，将一个字符串做成一个字符串数组。var arr1 = a.split(“”);//arr1 = [h,e,l,l,o] 12. length返回字符串的长度，所谓字符串的长度是指其包含的字符的个数。var len = a.length();//len = 5 13. toLowerCase将整个字符串转成小写字母。var lower_string = a.toLowerCase();//lower_string = “hello” 14. toUpperCase将整个字符串转成大写字母。var upper_string = a.toUpperCase();//upper_string = “HELLO”]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[工作总结]]></title>
      <url>%2F2017%2F08%2F12%2F10.%E5%B7%A5%E4%BD%9C%E6%80%BB%E7%BB%93(Nobook)%2F</url>
      <content type="text"><![CDATA[工作技能掌握 Node.js的fs文件系统， JSON与js对象的相互转换（parse，stringily） CSS的pointer-events（穿透） JS的apply 跟call JS的apply跟call每个函数都包含两个非继承来的方法：apply()跟call()。这两个方法都是在特定的作用域中调用函数，实际等于设置函数体内的this的=对象的值。apply(): 接受两个参数：1.在其中运行函数的作用域 参数数组：可以是Array的实例，也可以是arguments对象call():接受两个以上的参数，第一个参数是作用域，其余的所有参数直接传给对象。就是原来传递给函数的参数要罗列出来。 CSS的pointer-eventsPointer-events 字面意思是惦记鼠标事件，值常用的是auto 跟nonepointer-events: none; 表示它将捕获不到任何点击，让事件穿透到它的下面。pointer-events: auto; 默认值，将会捕获在这上边的事件。 JSON与js对象的相互转换首先看看JSON对象和JSON字符串的区别：JSON对象类似于JS对象，只是要对属性的使用“”双引号。而JSON字符串是在JSON对象外加上双引号。在数据传输过程中，json是以文本，即字符串的形式传递的，而JS操作的是JSON对象，所以，JSON对象和JSON字符串之间的相互转换是关键。看代码：下边看转化：JSON字符串转化为JSON对象，调用parse方法：Var jsonObj = JSON.parse(jsonStr);JSON对象转化为JSON字符串，调用stringily方法：Var jsonStr = JSON.stringify(jsonObj); 知识总结 jsfl使用flash_cs5_extengding.pdf来查看怎样书写代码和使用。 bit-101 flash actionScript 动画教程 flash actionScript 动画教程.pdf jQuery 的bind()用来绑定事件，绑定事件的格式为$(‘#button’).bind(‘click’, function(){ … }); unbind()解除通过bind绑定的事件，格式为$(‘#button’).bind(‘click’,function(){ … }); [jQuery 的事件命名空间]： (http://www.cnblogs.com/lyzg/p/5347857.html)]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[第五章 增强可访问性]]></title>
      <url>%2F2017%2F08%2F10%2F4.HTML5-CSS-5%2F</url>
      <content type="text"></content>
    </entry>

    
    <entry>
      <title><![CDATA[JQuery廖雪峰学习笔记]]></title>
      <url>%2F2017%2F08%2F07%2F13.JQuery%2F</url>
      <content type="text"><![CDATA[JQuery使用在head中直接引用JQuery文件$是JQuery符号，JQuery把所有功能全部封装在一个全局变量JQuery中，而$就是JQuery的别名。JQuery（$）本质上是一个函数，因此也是一个对象，$除了直接调用还有其他的属性。这里说一句，JQuery采用这种方式将他的方法和属性都包装到一个函数中，保护了他的属性和方法对外隐藏，是JS闭包的一种运用。 选择器选择器是JQuery的核心，其实JQuery的选择器很像CSS的格式 JS的DOM操作 JQuiery的DOM操作 document.getElementById(‘idName’) $(‘#idName’) document.getElementsByTagName(‘tagName’) $(‘tagName’) document.getElementsByClassName(‘className’) $(‘.className’) 通过$()查询返回的都是JQuery对象，JQuery对象类似数组，他的每个元素应用了DOM节点对象 如果查询的id不存在，返回[], 因此JQuery的选择器不会返回undefined或者null，JQuery的强大之处在于可以按照属性进行查找：123var email = $(&apos;[name = email]&apos;);var psd = $(&apos;[type = password]&apos;);var J = $(&apos;[属性 = 属性值]&apos;); 当然你还可以使用正则进行这样的查询:12var icons = $(&apos;[name ^= icon]&apos;); //找出所有name属性值以icon开头的DOMvar names = $(&apos;[name $= waith]&apos;); //找出所有name属性值以with结尾的DOM 这个方法适合通过class属性进行查找，且不受包含多个class名称的影响1var icons = $(&apos;[class ^= &quot;icon-&quot;]&apos;); // 找出所有class包含只少一个以icon-开头的DOM 也可以进行组合查找:12var emailInput = $(&apos;input[name=email]&apos;);//找到找出所有name属性值为email的input标签var tr = $(&apos;tr.red&apos;);//找到类名为.red的tr标签 还可以用,隔开进行组合一块选择：1$(&apos;p, div&apos;); // 把&lt;p&gt;和&lt;div&gt;都选出来 DOM对象和JQuery对象转化: DOM对象转换为JQuery对象： $(aDomObject); 这样就可以调用JQuery的API了JQuery对象转换为DOM对象： JQueryObj.get(index)获得数组中的一个DOM对象 选择器 例子 层级选择器 空格隔开 $(‘ul p input’) 子选择器 &gt; 隔开 $(parent&gt;child) 过滤器 选择器 作用 :first-child 选择第一个节点 :last-child 选择最后一个节点 :nth-child(n) 选择第n个节点,N从以开始 :nth-child(odd) 选择序号为奇数的节点元素 :nth-child(even) 选择序数为偶数的节点元素 查找和过滤查找 在当前节点的子节点中进行查找，用find()方法，find本身能接受任意一种选择器 从当前节点向上查找，用parent()方法 对于同一级的节点，用next()和prev()方法过滤 filter()方法可以过滤掉不符合选择器的节点，参数可以是一个函数，函数内部的this被绑定为DOM对象而不是JQuery对象 map()方法把一个JQuery对象包含的若干个DOM节点转化为其他对象 如果JQuery对象包含了不止一个DOM节点，first(), last()和slice()方法可以返回一个新的JQuery对象 操作DOM修改Text和HTMLjQuery对象的text()和html()方法分别获得节点的文本和原始的HTML文本，如果无参调用就是获取，传入参数就变成了设置文本。由于JQuery对象可以包含多个或者0个DOM对象，所以操作是在一组DOM对象上进行的，同样即使没有DOM对象也不会报错 修改CSSJQuery的‘批量操作’使得修改CSS很方便，调用JQuery对象的方法css(‘name’, ‘value’)，而且支持链式操作css()方法将作用于DOM节点的style属性，具有高优先级。修改class属性可以采用以下方法：jQueryObj.hasClass(‘className’); // 判断是否包含jQueryObj.addClass(‘className’); // 添加classjQueryObj.removeClass(‘className’); // 删除class 显示和隐藏DOM隐藏一个DOM可以设置CSS的属性display属性为none,但是显示的时候要知道之前的display属性，而JQuery直接提供了show()和hide()方法，隐藏了修改display的细节显示和隐藏DOM不改变DOM数的结构 获取DOM信息 通过jQuery对象的若干方法可以直接获得DOM的宽高信息// 浏览器可视窗口的大小$(window).width();$(window).height();// HTML文档的大小$(document).width();$(document).height();// 某个DIV的大小var div = $(‘#test-div’);div.width();div.height();div.width(400);div.height(‘200px’); // 设置CSS属性，是否生效要看CSS是否有效 attr()和removeAttr()用于操作DOM节点的属性 1234567// &lt;div id = &quot;test-div&quot; name = &quot;Test&quot; start=&quot;1&quot;&gt; ... &lt;/div&gt;var div = $(&apos;#test-div&apos;);div.attr(&apos;data&apos;); // undefined 属性不存在div.attr(&apos;name&apos;); // &apos;Test&apos;div.attr(&apos;name&apos;, &apos;Hello&apos;); // div的name属性变成了&apos;hello&apos;;div.removeAttr(&apos;name&apos;); // 删除name属性div.attr(&apos;name&apos;); // undefined prop()跟attr()类似，但是对于那种在节点中没有值，只有出现和不出现的属性例如 checked 123var radio = $(&apos;#test-radio&apos;);radio.attr(&apos;checked&apos;); // &apos;checked&apos;radio.prop(&apos;checked&apos;); // true 不过对于这种属性，用is最好 radio.is(‘:checked’); // true 类似的属性有selected is(‘:selected’) 操作表单对于表单元素，JQuery对象提供val()方法获取和设置对应的value属性，无参是获取，传入参数是设置 修改DOM结构添加DOM节点添加DOM节点除了使用html()这种暴力的方法外，还可以用append()方法，调用append()传入HTML片段（append()是添加子节点在最后）12var ul = $(&apos;#test-div&gt;ul&apos;);ul.append(&apos;&lt;li&gt;&lt;span&gt;Hask&lt;/span&gt;&lt;/li&gt;&apos;); append()除了接收字符串，还可以传入原始的DOM对象，JQuery对象和函数对象，传入函数时， 要求返回一个字符串，DOM对象或者JQuery对象。因为JQuery对象可能是一组DOM对象，只有传入函数才能针对不同的DOM对象生成不同的子节点prepend()把DOM添加在最前面after()和before()方法用于同级节点 删除节点remove()方法删除jQuery对象包括的所有DOM节点 事件由于浏览器绑定事件的方法不同，JQuery来写代码就屏蔽了浏览器的差异on()用来绑定一个事件，传入事件名称和对应的处理函数，也可以直接调用事件方法a.on(‘click’, function(){alter(‘Hello!’);}); 等价于 a.click(function(){alter(‘Hello!’);});jQuery 能够绑定的事件如下 鼠标事件click: 鼠标点击时触发;dbclick: 鼠标双击时触发;mouseenter: 鼠标进入时触发;mouseleave: 鼠标移开时触发;hover: 鼠标进入和移开时触发两个函数，相当于mouseenter加上mouseleave 键盘事件键盘事件仅作用于当前焦点的DOM上，通常是&lt;input&gt;和&lt;textarea&gt;keydown: 键盘按下时触发keyup: 键盘松开时触发keypress: 按一次键后触发 其他事件focus: 当DOM获得焦点时触发;blur: 当DOM失去焦点时触发;change: 当&lt;input&gt; &lt;textarea&gt; &lt;select&gt; 的内容发生改变时触发;submit: 当 &lt;form&gt;提交时触发;ready: 当页面被载入并且DOM树完后才能初始化后触发; 仅作用于document对象 ready事件在DOM完成初始化后触发，且触发一次。适合用来写其他的初始化代码$(docement).on(‘ready’, function () { … ;}); 等价于 $(document).ready(function (){ … ;}); 等价于 $(function () {}); 事件参数有些事件，如mousemove和keypress, 我们需要获得鼠标的位置和按键的值，这些事件都会传入Event对象作为参数，可以从Event对象上获得更多的信息12345$(function() &#123; $(&apos;#testMouseMove-div&apos;).mousemove(function(e) &#123; $(&apos;#testMouseMove-span&apos;).text(&apos;PageX = &apos; + e.pageX + &apos;, PageY = &apos; + e.pageY); &#125;)&#125;); 取消绑定通过off(‘click’, function)实现，移除的函数必须跟绑定的函数是同一个，如果是匿名函数就无法移除，可以使用off(‘click’)一次性移除已绑定的click事件的所有处理函数同理无参调用off()一次性移除已绑定所有类型的事件处理函数 事件触发条件事件的触发是通过用户操作引起的，如果我们通过JS代码去修改文本框的内容将不会触发change事件；如果希望用代码触发change事件，可以直接调用无参数的change()方法来触发该事件： input.val(‘change it’); input.change(); input.change() 相对于 input.trigger(‘change’), 它是trigger()方法的简写 浏览器安全限制在浏览器中有些JS代码只有在用户的触发下才能执行。例如window.open()函数 在JSdiamante中是不会被执行的，只有通过用户事件进行触发 动画这里我在工作中用的是Tween一系列的js库，感兴趣的可以关注我之后的文章更新。 这里介绍jQuery内置的几种动画 show()和hide(),无参调用show()和hide()会显示和隐藏DOM元素，但是，传入一个时间参数，就变成了动画。如 show(3000); // 在3秒内逐渐显示时间以ms为单位，但也可以是’slow’(0.6) ‘fast’这些字符串 show()和hide()是从左上角逐渐展开或者收缩的 toggle()方法根据当前状态决定是show()还是hide() slideUp()和slideDown()在垂直方向上逐渐展开或者收缩的slideUp()把一个DOM元素收起来，slideDown()相反，而slideToggle()是根据元素是否可见进行下一步操作的 fadeIn()和fadeOut()的动画效果是淡入淡出，也就是通过不断地设置DOM元素的opacity属性来实现的 fadeToggle()根据当前状态决定下一步操作自定义动画animate()可以实现任意动画效果，需要传入的参数就是DOM元素的最终CSS状态和时间123456var div = $(&apos;#test-div&apos;);div.animate(&#123; opacity: 0.25; width: &apos;256px&apos;; height: &apos;256px&apos;;&#125;, 3000); animate()还可以接受第三个参数，参数是一个回调函数，当动画结束时这个动画被调用12345678var div = $(&apos;#test-div&apos;);div.animate(&#123; opacity: 0.25; width: &apos;256px&apos;; height: &apos;256px&apos;;&#125;, 3000， function()&#123; console.log(&apos;动画结束&apos;);&#125;); 串行动画jQuery的动画可以串行执行，通过delay()方法还可以实现暂停， 这样我们可以实现复杂的动画效果123456789101112var div = $(&apos;#test-animates&apos;);div.slideDown(2000) .delay(1000) .animate(&#123; width: 200px; height: 256px; &#125;, 2000) .delay(1000) .animate(&#123; width: 100; height: 128; &#125;, 2000) 动画执行需要时间所以JQuery不断地返回新的Promise对象才能执行后续操作。 其他问题有时候动画没有效果， 是因为你执行动画的那个DOM元素不是块级元素可能有些属性没有。此外JQuery也没有实现background-color的动画效果，可以通过CSS3的transition实现动画效果。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[廖雪峰JS学习笔记2]]></title>
      <url>%2F2017%2F08%2F05%2F7.JS_Liao-2%2F</url>
      <content type="text"><![CDATA[浏览器对象Windowwindow对象不仅充当全局作用域，并表示浏览器窗口 window对象有innerWidth 和 innerHeight 属性，获得浏览器窗口的内部宽和高 outerWidth和outerHeight属性，可以获取整个浏览器的宽高 navigator 对象表示浏览器的信息，常用的属性：navigator.appName: 浏览器名称 navigator.appVersion: 浏览器版本 navigator.language 浏览器设置的语言 navigator.platform: 操作系统类型 navigator.userAgent: 浏览器设定的User-Agent字符串 screen 表示屏幕信息 常用属性：screen.width: 屏幕宽度，以像素为单位 screen.height: 屏幕高度，以像素为单位 screen.colorDepth: 返回颜色位数 location 表示当前页面的URL信息一个完整的URL： &gt; http://www.example.com:8080/path/index.html?a=1&amp;b=2#TOP 可以用location.href获取。要获得URL各个部分的值，可以这么写： 123456location.protocol; // &apos;http&apos;location.host; // &apos;www.example.com&apos;location.port; // &apos;8080&apos;location.pathname; // &apos;/path/index.html&apos;location.search; // &apos;?a=1&amp;b=2&apos;location.hash; // &apos;TOP&apos; 要加载一个新页面，可以调用location.assign()。如果要重新加载当前页面，调用location.reload()方法非常方便。 document 对象表示当前页面，整个DOM树的根节点###### document.title 改变标题 查找DOM树的某个节点：从document对象开始查找，最常用的就是根据ID和Tag Name document.getElementById(), getElementsByTagName() ###### document 还有一个cookie属性，可以获得当前页面的cookie history 对象保留了浏览器的历史记录，JS可以调用history的back()和forward()history对象不建议使用 更新DOM##### 修改节点的文本方法有两种： ###### 1.修改innerHTML属性：即可修改一个DOM节点的文本内容，也可以通过HTML片段修改DOM节点内部的子树 ###### 2. 修改innerText或textContent属性，直接对字符串进行HTML编码，无法设置任何HTML标签 在读取属性时，innerHTML不返回隐藏的文本，而textContent返回所有文本，IE&lt;9不支持textContent DOM节点的style属性对应所有的CSS，fontSize对应CSS中的font-size 插入DOMinnerHTML会替换原来的所有节点，所以插入节点有两个其他方法： 1.appendChild() 把一个子节点添加到父节点的最后一个子节点 动态创建一个节点然后添加到DOM树种可以实现很多功能：添加CSS格式： 1234var d = document.createElement(‘style’);d.setAttribute(‘type’, ‘text/css’);d.innerHTML = ‘p &#123; color: red &#125;’;document.getElementsByTagName(‘head’)[0].appendChild(d); 2. insertBefore 把子节点插入到指定位置 用法： parentElement.insertBefore(newElement, referenceElement); 子节点会插入到referenceElement 之前 循环一个父节点的所有子节点通过迭代children属性实现： 12345var i, c,list = document.getElementById(‘list’);for (i = 0; i &lt; list.children.length; i++) &#123; c = list.children[i];&#125; 删除DOM删除节点需要获得该节点本身跟他的父节点，调用父节点的removeChild把自己删掉 删除的节点虽然不在文档树中，但其实他还在内存中，可以随时被添加到别的位置 children属性是一个只读属性，并且它在子节点变化时会时时更新，因此删除多个节点时，children属性时刻都在变化 操作表单用JS操作表单和操作DOM一样， JS操作表单可以获得用户的输入或者对一个输入框设置新的内容 表单控件：* 文本框，&lt;input type = “text”&gt; 用于输入文本 * 口令框， &lt;input type = “password”&gt; 用于输入口令 * 单选框， &lt;input type = “radio”&gt; 用于选择一项 * 复选框，&lt;input type = “checkbox”&gt; 用于选择多项 * 下拉框，&lt;select&gt; 用于选择一项 * 隐藏文本， &lt;input type = “hidden”&gt; 用户不可见，但表单提交时会把隐藏文本发送到服务器 获取值首先获得节点的引用， 然后调用**value**获得对应的用户的输入值，对于radio 和 checkbox 获得是否勾选通过**checked**进行判断 设置值和获取值类似，对于text , password, hidden, select 直接设置**value** 对于radio和checkbox，设置**checked** 为true或者false即可 HTML5控件新增常用： date, datetime, datetime-local, color等，他们都是用&lt;input&gt;标签 如： &lt;input type = “date” value = “2015-07-01”&gt; 提交表单两种方式： * 1.通过**form**元素的submit()方法提交表单 * 2.浏览器默认点击&lt;button type = “submit”&gt;时提交表单，或者是在最后一个输入键按回车，因此可以通过相应&lt;form&gt;本身的onsubmit事件。onsubmit = “return checkForm()” 12345678910111213&lt; form id = “login=form” methon = “post” onsubmit = “return checkForm()”&gt; &lt;input type = “text” id = “username” name = “username”&gt; &lt;input type = “password” id = “input-password”&gt; &lt;input type = “hidden” id = “md5-password&quot; name = “password”&gt; &lt;button type = “submit”&gt;Submit&lt;/button&gt;&lt;/form&gt;&lt;script&gt; function checkForm() &#123; var input_pwd = document.getElementById(‘input-password’); var md5_pwd = document.getElementById(‘md5-password’); md5_pwd.value = toMD5(input_pwd.vaule); return true; &#125; Type为hidden用户不可见， 同时因为设置了name属性的&lt;input&gt;的数据会被提交，没有name属性的就不会被提交。 操作文件上传文件的唯一控件 type = “file”> ```1234567891011121314151617 ** 注意： 当一个表单包含``` &lt;input type = “file”&gt; ```时，表单的enctype必须制定为multipart/form-data, method必须指定为post， 浏览器才能正确的编码并且以multipart/form-data格式发送表单数据 ** 浏览器只允许选择本地文件因此不能通过改变value的方式来改变文件路径，也不能获得文件的真实路径 #### File API 新增的file API 允许JS获取文件内容，H65新增的File API主要有File和FIleReader两个主要对象 ### AJAX AJAX并不是JS的规范， 他是Asynchronous JavaScript and XML 意识就是用JS执异步网络请求。 Web 运作原理： 一次HTTP请求对应一个页面 而AJAX请求时异步的，要通过回调函数获得响应 现在浏览器上写AJAX主要依靠XMLHttpRequest对象 var request = new XMLHttpRequest(); // 新建XMLHttpRequest对象 Request.onreadystatechange = function() &#123; 状态发生变化时， 函数被回调 &#125; 低版本的IE使用ActiveXObject对象 Var request = new ActiveXObject(‘Microsoft.XMLHTTP’); 通用：var request; if (window.XMLHttpRequest) { request = new XMLHttpRequest(); } else { request = new ActiveXObjext(&apos;Microsoft.XMLHTTP&apos;); // 针对低版本IE } ``` 创建对象后，首先设置onreadystatechange的回调函数，在回调函数中通过你readyState === 4 来判断是否完成， 在根据status === 200 判断是否是一个成功的响应。 XMLHttpRequest对象三个重要属性： | 属性 | 描述 | | :----- | :----- | |onreadystatechange | 每当readyState属性变化时调用的函数 | | readyState | 存有XMLHttpRequest的状态， 从0 到 4 变化 | | status | 两个值200 404 | 0： 请求未初始化 1： 服务器连接已建立 2： 请求已接收 3： 请求处理中 4： 请求已完成，且响应就绪 200： “OK” 404: 未找到页面 如果需要将请求发送到服务器，要使用XMLHttpRequest对象的open()和send()方法 - open(methon, url, async) 方法规定了请求的类型，URL，和是否异步 XMLHttpRequest对象的open()方法有三个参数，第一个参数指定是GET还是POST， 第二个参数指定URL地址， 第三个参数指定是否使用异步，默认为true, 所以不写 Async = true时才有onreadystatechange函数，为false时直接把代码放到send()方法后即可（参考W3AJAX） GET和POST的区别：与POST相比， GET更简单也更快，并且在大多数下都能用，例外在以下场景用POST： 1. 无法使用缓存文件 2. 向服务器发送大量数据（POST没有数据量 限制） 3. 发送包含未知字符的用户输入时， POST比GET更稳定和更可靠 4. GET使用URL或Cookie传参，而POST将数据放在BODY中 - send(string) 将请求发送到服务器， string仅用于POST请求 服务器响应获得服务器的响应，使用XMLHttpRequest对象的responseText和responseXML属性 | 属性 | 描述 | | :----- | :----- | | responseText | 获得字符串形式的响应数据 | | responseXML | 获得XML形式的响应数据 | 安全限制由于浏览器的同源策略，JS在发送AJAX请求时，URL的域名必须和当前的页面完全一致：域名要一致，协议要相同(http和https不同), 端口号要相同 JS有大致三种方式去请求域外的URL 1. 通过Flash插件发送HTTP请求，已经快被淘汰 2. 在同源域名下架设一个代理服务器进行转发，JS负责把请求发送到代理服务器，代理服务器再把结果返回，这样就遵循了同源策略。 3. JSONP利用了浏览器允许跨域引用JS资源，限制是只能使用GET请求，并且要求返回JS。 具体的做法就是： 先在页面中准备好回调函数，然后给页面添加一个&lt;script&gt;节点，相当于动态的读取域外的JS资源 H5的跨域策略： CORSCORS全称： Cross-Origin Resourse Sharing 跨域资源共享 Origin表示当前页面的域，当JS想域外发起请求时，浏览器收到响应后，首先检查Access-Control-Allow-Origin 是否包含本域。 &gt; 用一个图来表示就是： 假设本域是my.com，外域是sina.com，只要响应头Access-Control-Allow-Origin为http://my.com，或者是*，本次请求就可以成功。 canvasCanvas时HTML5的新增组件， 他就像一个画布，可以用JS在上面绘制各种图表，动画等 PromisePromise对象是一种“承诺将来会执行”的对象。 可见Promise最大的好处是在异步执行的流程中，把执行代码和处理结果的代码清晰地分离了：]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[廖雪峰JS学习笔记]]></title>
      <url>%2F2017%2F08%2F04%2F6.JS_Liao-1%2F</url>
      <content type="text"><![CDATA[JavaScript 发展历程：1.网景公司95年发布JavaScript 2.ECMAScript 是标准，JavaScript是具体实现 3.ES6 15年六月发布 快速入门1.将代码放到网页的任何地方，用&lt;script&gt; … &lt;/script&gt;包含JavaScript的代码 2.将JS代码放在单独的JS文件中，&lt;script src=“”&gt; … &lt;/script&gt;引入文件 3.JS区分大小写 数据类型和变量number；字符串：’abc’ “abc”;布尔值；&amp;&amp; ；||；！； 1.== 和=== ；==会先进行数据类型的转换，===数据类型不同直接返回false，尽量使用=== 2.NaN与所有值都不相等，包括他自己 NaN === NaN; //false isNaN(NaN); //true 3.浮点数的比较，通过差值的绝对值小于某个阀值 4.null和undefined 5.数组，对象，变量：变量名是大小写英文、数字、$和_的组合，且不能用数字开头。变量名也不能是JavaScript的关键字，如if、while等。 6.不用var申明的都是全局变量，var申明的是局部变量，范围别限制在该变量神明的函数题内 7.使用严格模式：’use strict’ 字符串1.转义符\：\n表示换行，\t表示制表符，\\表示\自身 ASCII字符用\x##形式的十六进制表示 ‘\x41’ //等同于’A’ Unicode字符用\u###表示： ‘\u4e2d\u6587’ //等同于’中文’ 2.多行字符串用\n表示费事，ES6新的字符串的表示方法： 反引号` … `表示 3.使用+比较麻烦，ES6新增模板字符串，表示方法和上边一样，用` … `包起来 如： var message = `你好, ${name}, 你今年${age}岁了!`; 字符串的操作：var s = “Hello World!”;详见’JS字符串操作’文档 1.s.length取长度,s[0];//‘h’,需要注意的是，字符串是不可变的，如果对字符串的某个索引赋值，不会产生错误但是也不会产生结果 2.JavaScript为字符串提供了一些常用方法，注意，调用这些方法本身不会改变原有字符串的内容，而是返回一个新字符串： * toUpperCase()把一个字符串全部转换成大写； * toLowerCase()把一个字符串全部转换成小写； * indexOf(str)从首位检索指定字符串出现的位置；没有返回-1 * lastIndexOf(str)从末尾检索指定字符串出现的位置；没有返回-1 * substring(start, end)返回指定索引区间的子串； * slice(start, end)提取一个字符串的一部分，返回新的字符串； * substr(start, length)返回字符串的一个子串； * split(“”)将一个字符串转换成一个字符串数组； * concat(str)将两个或多个字符的文本组合起来，返回新的字符串； * charAt(index)返回指定位置的字符： a = ‘hello’; var get_char = a.charAt(0); //get_char = ‘h’; * match(正则表达式)检查以恶搞字符串匹配一个正表达式内容，没有匹配返回null 数组1. 数组长度length 2. 数组搜索：indexOf()返回元素的索引（位置） 3. 数组截取：slice(start, end)对应string的substring，可以没有任何参数，相对于复制了数组 4. push()向数组的末尾添加若干元素，pop()删除数组的最后一个元素； 5. unshift()向数组的头部添加若干元素，shift()将数组的第一个元素删除； 6. sort()对当前数组排序，按照默认顺序排序； 7. reverse()反转数组元素； 8. splice()方法是修改数组的万能方法，它可以从指定索引删除若干元素，然后再从改位置添加若干元素 12345678910var arr = [&apos;Microsoft&apos;, &apos;Apple&apos;, &apos;Yahoo&apos;, &apos;AOL&apos;, &apos;Excite&apos;, &apos;Oracle&apos;];// 从索引2开始删除3个元素,然后再添加两个元素:arr.splice(2, 3, &apos;Google&apos;, &apos;Facebook&apos;); // 返回删除的元素 [&apos;Yahoo&apos;, &apos;AOL&apos;, &apos;Excite&apos;]arr; // [&apos;Microsoft&apos;, &apos;Apple&apos;, &apos;Google&apos;, &apos;Facebook&apos;, &apos;Oracle&apos;]// 只删除,不添加:arr.splice(2, 2); // [&apos;Google&apos;, &apos;Facebook&apos;]arr; // [&apos;Microsoft&apos;, &apos;Apple&apos;, &apos;Oracle&apos;]// 只添加,不删除:arr.splice(2, 0, &apos;Google&apos;, &apos;Facebook&apos;); // 返回[],因为没有删除任何元素arr; // [&apos;Microsoft&apos;, &apos;Apple&apos;, &apos;Google&apos;, &apos;Facebook&apos;, ‘Oracle’] 9. concat([other array])把当前数组和另一个数组链接起来，并返回新的数组 10. join(‘-’)把数组当前的元素都用指定的字符串链接起来，并且返回连接后的字符串，array中元素不是字符串，会先进行转换 对象1. JS对象是一种无序的集合数据类型，由若干键值对组成 2. 属性的访问，.或者[‘’]或者[“”]，没有的属性返回undefined 3. JS对象是动态类型，可以给对象添加或者删除属性 4. 检测对象是否拥有某一属性，可以用in操作符，但是in判断属性会检查对象的父类，有可能是对象继承而来的属性 5. 判断一个属性是否是对象本身拥有，使用hasOwnProperty()方法 判断条件1.if{ …. } else{ …. } 2.JS把null，undefined，0，NaN和空字符串’’视为false，其他一律为true 循环1. for(初始条件;判断条件;递增条件){ … }，for循环常用来利用索引遍历数组 2. for … in循环，把一个对象的所有属性依此循环出来，要过滤掉对象继承的属性，使用hasOwnProperty()来实现 for … in 对数组循环得到的是String而不是Number 3. while(){ … }; do{ … }while(); Map和Set1. Map是一组键值对的结构，具有极快的查找速度 map的方法有get()和set(); 2. Set和Map类似，也是一组key的集合，但不存储value。在Set中没有重复的key。重复元素在Set中被自动过滤。 add(key)方法可以向Set中添加元素，可以重复添加，但是没有效果。 delete(key)方法删除元素。 iterable1. Array，Map，Set都属于iterable类型 2. iterable类型集合可以通过for...of循环来遍历 for … of 与for … in的区别： for ... in循环由于历史遗留问题，它遍历的实际上是对象的属性名称。一个Array数组实际上也是一个对象，它的每个元素的索引被视为一个属性 var a = [&apos;A&apos;, &apos;B&apos;, &apos;C&apos;]; a.name = &apos;Hello&apos;; for (var x in a) { alert(x); // &apos;0&apos;, &apos;1&apos;, &apos;2&apos;, &apos;name&apos; } for ... in循环将把name包括在内，但Array的length属性却不包括在内。 for ... of循环则完全修复了这些问题，它只循环集合本身的元素： var a = [&apos;A&apos;, &apos;B&apos;, &apos;C&apos;]; a.name = &apos;Hello&apos;; for (var x of a) { alert(x); // &apos;A&apos;, &apos;B&apos;, &apos;C&apos; } 3. iterable 的内置forEach()方法，它接受一个函数，每次迭代久自动回调该函数。 for example： var a = [‘a’, ‘b’, ‘c’]; a.forEach(function(element, index, array)){ //element: 指向当前元素的值 //index: 指向当前索引 //array: 指向Array对象本身 alert(element); } Set没有索引，因此回调函数的前两个参数都是元素本身 s.forEach(function(element, sameElement, set){ … }); Map的回调函数参数依次是value，key, 和map本身 m.forEach(function(value, key, map){ … }); 函数1. JS中的函数是头等公民，具有强大的抽象能力 2. 函数的定义 function abc(){ if(x&gt;=0){ return x; } else return -x; } • function指出这是一个函数定义； • abs是函数的名称； • (x)括号内列出函数的参数，多个参数以,分隔； • { ... }之间的代码是函数体，可以包含若干语句，甚至可以没有任何语句。 JS 函数也是对象，因此abc()函数实际上是一个函数对象，函数名可以看成指向该函数的变量 var abc = function(x){ … };与上边的等价 3.函数的调用abc(90); abc(); abc(1,90,x); 4.arguments只在函数的内部起作用，并且永远指向当前函数的调用者传入的所有参数。 变量作用域1. 在函数内部声明的变量，该变量的作用域为整个函数体，函数体外不可引用该变量 2. 不同函数内部的同名变量相互独立，互不影响 3. 在嵌套函数中，内部函数可以访问外部函数的变量，反过来不行 4. 函数在查找变量是从自身函数开始，由内向外查找，如果函数内部定义了与外部函数同名的变量，内部函数的变量将屏蔽外部函数的变量 5. 变量提升：把所有声明的变量提升到函数顶部，JS引擎提升变量的声明，但是不会提升变量的赋值。 因此在JS中，请严格遵守“在函数内部首先声明所有的变量”这一规则，常用的方法是用 一个var申明函数内部用到的所有变量 全局作用域1. 不在任何函数内定义的变量就具有全局作用域，JS有一个默认的全局对象Window，全局作用域的变量实际上被绑定到window的一个属性 2. 顶层函数的定义被视为一个全局变量，并绑定到window对象 3. JS实际上只有一个全局作用域，任何变量（函数也视为是变量），如果在当前作用域中没有找到，就会继续向上查找。在全局作用域也没找到，则报ReferenceError错误。 名字空间1. 全局变量会绑定到window上，不同JS文件如果使用了相同的全局变量，就会造成命名冲突。 2. 减少冲突的方法是把自己的所有变量和函数全部绑定到一个全局变量中 局部作用域1.JS变量的作用域是函数内部，因此在for循环等语句块无法定义具有局部作用域的变量 2.为了解决块级作用域，ES6引入关键字let，用let可以声明一个块级作用域的变量 常量1.在ES6之前用大写的变量表示这是一个变量 2.ES6引入新的关键字const定义变量，const与let都具有块级作用域 方法1. 方法其实就是函数，但是一般称绑定在对象上的函数称为方法 2. 在方法内部，this是一个特殊变量，指向对前对象，就是方法绑定的那个对象 3. 以对象的方法形式调用，函数的this指向被调用的对象，如果单独调用，this指向全局变量即window。在strict模式下，this指向undefined的，因此在strict模式下，会得到一个 错误 12345678910111213&apos;use strict&apos;;var xiaoming = &#123; name: &apos;小明&apos;, birth: 1990, age: function () &#123; function getAgeFromBirth() &#123; var y = new Date().getFullYear(); return y - this.birth; &#125; return getAgeFromBirth(); &#125;&#125;; xiaoming.age(); // Uncaught TypeError: Cannot read property &apos;birth&apos; of undefined 结果又报错了！原因是this指针只在age方法的函数内指向xiaoming，在函数内部定义的函数，this又指向undefined了！（在非strict模式下，它重新指向全局对象window！） 修复的办法也不是没有，我们用一个that变量首先捕获this： apply1. 在单独的函数调用时，this指向window或者undefined，不过我们可以控制this的指向 2. 调用函数的apply方法，指定函数的this指向。apply接受两个参数，第一个参数是需要绑定的this变量，第二个参数是Array，表示函数本身的参数getAge.apply(xiaoming, []); 3. call()跟apply一样，只是apply把参数打包成Array再传入，call()把参数顺序传入 4. 对普通函数的调用，我们可以把this绑定为null 装饰器1. 利用apply()，可以动态改变函数的行为 高阶函数1. 高阶函数：higher-order function。函数可以接受另一个函数作为参数，这样的函数就是高阶函数，下边的都是一些高阶函数 2. map()方法，map()方法定义在JS的Array中，我们调用Array的map()方法，传入我们自己的函数，就得到一个新的Array作为结果。对数组中每一个元素调用我们的方法 3. reduce()方法，Array的reduce()方法把一个函数作用在Array的[x1,x2,x3..]上，这个函数必须接受两个参数，reduce()把结果和序列的下一个元素做累积计算。 4. filter()方法，Array的filter()方法接受一个“筛选”函数，把该函数作用与数组的每个元素，然后根据返回值的true和false决定保留还是丢弃该元素。filter()接受回调函数，可以有多个参数，第一个元素表示Array的某个元素，第二个参数表示元素的位置，第三个表示数组本身 5. sort()方法，数组的sort()方法默认把所有元素转化成String，然后在排序。sort()也是高阶函数，它可以接受一个比较函数来实现自定义排序。忽略大小比较字符串，要将字符串都变成小写或者大写。sort()方法直接对Array进行修改。 闭包1. 高阶函数除了可以接受函数参数外，还可以将函数作为结果返回。 2. 返回闭包时牢记返回函数不要引用任何循环变量，或者后续会发生变化的变量 3. 创建一个匿名函数并立即执行 (function(x){return x * x;}) (3); 4. 闭包就是携带状态的函数，并且他的状态完全对外隐藏 箭头函数1. 箭头函数相当于匿名函数，（参数）=&gt; { 函数体 } 2. 当只有一个函数参数跟一条语句时简写为 x =&gt; x*x; return 都可以省略 如果想要返回一个对象，函数体的{}跟对象的{}有冲突，可以用()扩起来： x =&gt; ({foo: x }) 3. 箭头函数与匿名函数的区别，箭头函数内部的this是词法作用域，由上下文确定 4. 由于this在箭头函数中已经按照词法作用域绑定了， 所以用call()和apply() 调用箭头函数时，无法用this进行绑定。即第一个传入的参数将被忽略。 generator1. generator(生成器)时ES6引入的新的数据类型，看上去是一个函数，但是可以返回多次。 2. generator和函数的不同是：generator由function* (注意*)定义，除了return语句，还可以用yield返回多次。 3. 直接调用generator，仅仅是创建了一个generator对象，而没去执行它，调用generator对象有两个方法： 一个是不断的调用generator对象的next()方法，next方法会执行generator的代码，然后每次遇到yield x; 就会返回一个对象{value: x, done: true/false},value就是yield的返回值，done表示这个generator是否执行结束。如果done为true，value就是return的返回值。 一个是直接调用for … of 循环迭代generator对象，这种方式不需要自己判断done 4.generator看上去是一个可以记住状态的函数，generator可以写出需要面向对象才能实现的功能，generator就是把异步回调变成同步代码 标准对象1. 在JS世界中，一切都是对象，为了区别对象的类型，用typeof操作符获取对象的类型，他总是返回一个字符串。null 和array的类型也是object，使用typeof无法区分出null，Array和通常意义上的对象{} 2. 包装对象 遵守： • 不要使用new Number()、new Boolean()、new String()创建包装对象； • 用parseInt()或parseFloat()来转换任意类型到number； • 用String()来转换任意类型到string，或者直接调用某个对象的toString()方法； • 通常不必把任意类型转换为boolean再判断，因为可以直接写if (myVar) {...}； • typeof操作符可以判断出number、boolean、string、function和undefined； • 判断Array要使用Array.isArray(arr)； • 判断null请使用myVar === null； • 判断某个全局变量是否存在用typeof window.myVar === &apos;undefined&apos;； • 函数内部判断某个变量是否存在用typeof myVar === &apos;undefined&apos;。 ** 任何对象都有toString()方法吗？null和undefined就没有！确实如此，这两个特殊值要除外，虽然null还伪装成了object类型。 ** Number对象调用toString()报错，123.toString(); // 错误 正确的： 123..toString(); 或者 (123).toString(); Date1.要获取系统当前时间，用var now = new Date(); 可以使用now.getFullYear();获得月份；使用now.getMonth();获得月份等等 2.当前时间是浏览器从本机的操作系统获取的时间，因此不一定准确。创建一个指定日期：var d = new Date(2015, 5, 19, 20, 15, 30, 123); 3.在JS中，0表示一月份，一次类推。 RegExp 正则表达式- \d 匹配一个数字， \w匹配一个字符或者数字 - . 匹配任意一个字符 - * 表示任意个字符（包括0个），+ 表示至少一个字符， ？表示0个或者1个字符， {n} 表示n个字符，{n,m} 表示n-m个字符 - \s匹配一个空格（也包括Tab等空格符） - A|B 可以匹配A也可以匹配B - ^ 表示行的开头，$表示行的结束 ^\d 表以数字开头 \d$表示以数字结尾 - []表示范围 [0-9a-zA-Z\_]可以匹配一个数字字符或者下划线 javaScript中正则表达式的创建 1. ／正则表达式／flags 2. new RegExp(‘正则表达式’) RegExp对象的test() 方法用于测试给定字符串是否符合条件 使用： 切分字符串： ‘a b c’.split(‘ ’); // [‘a’, ‘b’, ‘’, ‘’, ‘’, ‘c’] ‘a b c’.split(/\s+/); // [‘a’, ‘b’, ‘c’] ‘a,b, c d’.split(/[\s\,]+/); 分组： 正则表达式可以提取子串，用()表示要提取的分组 如：^(\d{3}) - (\d{3,8})$ 定义的组，就可以再RegExp对象上用exec()方法提取子串 exec()方法匹配成功后，会返回一个Array，第一个元素是匹配到的整个字符串，后边的字符串表示匹配成功的子串 3. 贪婪匹配： \d+ 贪婪匹配 \d? 非贪婪匹配 4. flags g 表示全局匹配 i 表示忽略大小写 m 表示多行匹配 JSONJSON的字符集必须是UTF-8，JSON必须用双引号“” 1. 将JS对象序列化成JSON格式的字符串： JSON.stringify(obj, null, ‘ ‘); 第二个参数用于控制筛选对象的键值，只输出制定的属性， 可以传入Array： JSON.stringify(obj, [‘name’, ‘skill’], ‘’); 也可以传入一个函数，对象的每个键值对都被函数先处理 可以将一个JSON对象添加一个toJSON方法，直接返回JSON应该序列化的数据 2. 反序列化 JSON.parse()将JSON格式的字符串变成JS对象 JSON.parse(‘{“name”: “小明”, “age”:14}’, function(key, value) { 用来解析属性}) 面向对象obj._proto_改变对象的原型 Object.create()方法可以传入一个原型对象，并创建一个基于该原型的新对象 1. 创建对象 JS对每个创建的对象设置一个原型，只想他的原型对象 arr—-&gt; Array.prototype —-&gt; Object.prototype —-&gt; null 2. 构造函数 定义一个函数，通过new 关键字来调用这个函数，并默认返回this 通过new Student()创建的对象还从原型上获得一个constructor属性， 它指向函数Student本身 3. 原型继承 #### class继承 class从ES6引入 class Student(name) { constructor(name) { this.name = name; } hello() { alert(‘Hello’); } }]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[图片模糊和灰度处理，边界检测]]></title>
      <url>%2F2017%2F05%2F31%2F5.BlurImage%2F</url>
      <content type="text"><![CDATA[图像卷积和滤波的一些知识滤波过程：对图像的每一个像素点，计算他邻域的像素和滤波器矩阵（卷积核）的对应元素的乘积，然后加起来作为该点的像素值卷积和协相关： 对图像和滤波矩阵进行逐个的元素相乘再求和的操作就相当于将一个二维函数转移到另一个二维函数的所有位置，这个操作就是卷积或者协相关 区别： 卷积要先对滤波矩阵进行180的翻转 滤波器的规则： 滤波器大小为奇数，有中心有半径： 如3X3，5X5 滤波器所有元素之和为1，保证图片亮度不变。&gt;1 更亮，&lt;1 变暗 出现负数和大于255直接截断或者取绝对值 图像知识：一个图片有宽高，在屏幕上他的宽高分别代表了宽多少个像素，高有多少个像素，一个像素点有四个值：r,g,b,a。那么遍历图像的所有像素有：123456789for (let i = 0; i &lt; picture.width; i++) &#123; for (let j = 0; j &lt; picture.height; j++) &#123; let k = (j * width + i) * 4; pixes[k] // r pixes[k+1] // g pixes[k+2] // b pixes[k+3] // a &#125;&#125; 高斯模糊：实例：1.高斯模糊]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[第四章CSS3使用]]></title>
      <url>%2F2017%2F03%2F25%2F3.HTML5-CSS-4%2F</url>
      <content type="text"><![CDATA[HTML5和CSS3学习笔记CSS特性： 特性 用法 nth-of-type [p:nth-of-type(2n+1){color: red;}] first-child [p:first-child{color:blue;}] nth-child [p:nth-child(2n+1){color:red}] last-child [p:last-child{color:blue;}] nth-last-child [p:nth-last-child(2n+1){color:red}] first-of-type [p:first-of-type{color:blue}] last-of-type [p:last-of-type{color:blue}] after 与content一起使用，在指定元素后加内容 对列的支持 将内容区域分成多列 媒体查询 基于设备设置应用样式 多列布局1234567891011\#content&#123; column-count: 2; -moz-column-count: 2; -webkit-column-count: 2; column-gap: 20px; -moz-column-gap: 20px; -webkit-column-gap: 20px; column-rule: 1px solid #ddccb5; -moz-column-rule: 1px solid #ddccb5; -webkit-column-rule: 1px solid #ddccb5;&#125; 媒体查询CSS3的媒体查询允许开发人员根据方可的屏幕尺寸大小来调整整个页面的渲染效果，媒体查询可以查询一下内容：分辨率，方向，设备的宽高，浏览器窗口的宽高 如：在样式表结束添加：123456789@media only screen and (max-device-width: 480px) &#123; body&#123; width: 460px; &#125; section#sidebar, section#posts&#123; float: none; width: 100%; &#125;&#125; 也可以在关联样式表时，使用媒体查询，然后将移动设备的样式表放入单独的文件中1&lt;link rel = &quot;stylesheet&quot; type = &quot;text/css&quot; href = &quot;CSS/monile.css&quot; media = &quot;only screen and (max-device-width: 480px)&quot;&gt; 实例：1.优化的付款清单]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[第三章创建易用的web表单]]></title>
      <url>%2F2017%2F03%2F21%2F2.HTML5-CSS-3%2F</url>
      <content type="text"><![CDATA[HTML5和CSS3学习笔记常用的表单输入域： 类型 用法 &lt;input type=”email”&gt; 显示一个输入邮件地址的表单域 &lt;input type=”url”&gt; 显示一个输入URL的表单域 &lt;input type=”tel”&gt; 显示一个输入电话号码的表单域 &lt;input type=”search”&gt; 显示一个输入搜索关键字的表单域 &lt;input type=”range”&gt; 显示一个滑块组件 &lt;input type=”number”&gt; 显示一个输入数值的表单域 &lt;input type=”date”&gt; 显示用于日期选择的表单域 &lt;input type=”datetime”&gt; 显示用于日期选择和时间选择的表单域 &lt;input type=”text” autofocus&gt; 支持将焦点置于特定的表单元素上 &lt;input type=”email” placeholder=”me@example.com”&gt; 在表单中显示占位文本 &lt;p contenteditable&gt;lorem ipsum&lt;/p&gt; 支持通过浏览器在位编辑内容 实例 实例1 基础表单 实例2 注册表单(含有动态验证码)]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[第二章新的结构标签和属性]]></title>
      <url>%2F2017%2F03%2F18%2F1.HTML5-CSS-2%2F</url>
      <content type="text"><![CDATA[HTML5和CSS3学习笔记1.新的结构标签和属性 结构标签 用法 &lt;header&gt; 定义页面或区段的头部 &lt;footer&gt; 定义页面或者区段的尾部 &lt;nav&gt; 定义页面或者区段的导航区域 &lt;section&gt; 定义页面的逻辑区域或内容组合 &lt;article&gt; 定义正文或一片完整的内容 &lt;aside&gt; 定义补充或相关内容 &lt;meter&gt; 描述指定范围内的数值 &lt;progress&gt; 用于显示实时进度的控件 自定义的数据属性 允许通过“data-”前缀向任意元素中添加自定义的数据属性 2.实例：用语义化标记重新定义博客12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;header id=&quot;page_header&quot;&gt; &lt;h1&gt;Hello World!&lt;/h1&gt; &lt;nav&gt; &lt;ul&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;Home&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;Articles&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;About me&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;Contact me&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/nav&gt; &lt;/header&gt; &lt;section id=&quot;posts&quot;&gt; &lt;article class=&quot;post&quot;&gt; &lt;header id=&quot;section_header&quot;&gt; &lt;h2&gt;Welcome to my blog!&lt;/h2&gt; &lt;p&gt;Posted by GuoRuiyang on &lt;time datetime=&quot;2017-03-18T16:27&quot;&gt;March 18st, 2017 at 4:27PM&lt;/time&gt;&lt;/p&gt; &lt;/header&gt; &lt;aside&gt; &lt;p&gt;&amp;quot;Never give someone a chance to say no when you selling your product.&amp;quot;&lt;/p&gt; &lt;/aside&gt; &lt;P&gt; Life is full of confusing and disordering Particular time,a particular location,Do the arranged thing of ten million time in the brain,Step by step ,the life is hard to avoid delicacy and stiffness No enthusiasm forever,No unexpected happening of surprising and pleasing So,only silently ask myself in mind Next happiness,when will come? &lt;P&gt; &lt;P&gt; Then the wandering soul wild crane stands still the memory river Listen to whistle play tightly ring slowly,Water rises a ship to go medium long things of the past.Wait for a ship’s person Wait for one and other,But hesitate always should ascend which ship Missed Had to consign the hope to next time,Finally what to wait for until has no boats and ships to come and go,Sunset west . &lt;/P&gt; &lt;footer id=&quot;article_footer&quot;&gt;&lt;p&gt;&lt;a href=&quot;#&quot;&gt;&lt;i&gt;25 comments&lt;/i&gt;&lt;/a&gt;.....&lt;/p&gt;&lt;/footer&gt; &lt;/article&gt; &lt;footer&gt;&lt;/footer&gt; &lt;/section&gt; &lt;section id=&quot;sidebar&quot;&gt; &lt;header&gt;&lt;h3&gt;Archives&lt;/h3&gt;&lt;/header&gt; &lt;nav&gt; &lt;ul&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;Home&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;Articles&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;About me&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;Contact me&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/nav&gt; &lt;/section&gt; &lt;footer id=&quot;page_footer&quot;&gt; &lt;p&gt;@copy;2017GuoRuiyang.&lt;/p&gt; &lt;ul&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;Home&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;Articles&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;About me&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;Contact me&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/footer&gt;&lt;/body&gt;&lt;/html&gt;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Hello World]]></title>
      <url>%2F2017%2F03%2F15%2F0.hello-world%2F</url>
      <content type="text"><![CDATA[欢迎来到我的博客，在我花费了（牺牲了）我两个晚上的打游戏的时间，把自己的博客网站给搭建起来了。我是一名程序猿，所以从Hello World!开始。我的博客里会更新自己的一些学习笔记和一些原创的个人文章，希望给大家呢带来知识和快乐。技术文章转载希望能够注明转载，同样我也会注明自己的转载。 &gt; 如果智慧与美貌不能并存，那我算什么。 *沃.兹季硕德*]]></content>
    </entry>

    
  
  
</search>
