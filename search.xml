<?xml version="1.0" encoding="utf-8"?>
<search>
  
    
    <entry>
      <title><![CDATA[常见排序算法的JS实现]]></title>
      <url>%2F2017%2F08%2F16%2F%E5%B8%B8%E8%A7%81%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E7%9A%84JS%E5%AE%9E%E7%8E%B0%2F</url>
      <content type="text"><![CDATA[常见的排序算法1. 冒泡排序，原理： 一次比较相邻的两个数， 如果前边的大就交换位置，这样一轮下来，最后一个是最大的。 对除了最后一个数重复第一步，直到只剩一个数代码实现：12345678910111213141516171819202122function bubbleSort(myArray)&#123; var len = myArray.length; for (let i = 0; i &lt; len-1; i++) &#123; for(let j = 0, stop = len - i - 1; j &lt; stop; j++) &#123; if(myArray[j] &gt; myArray[j+1]) &#123; let temp = myArray[j]; myArray[j] = myArray[j+1]; myArray[j+1] = temp; &#125; &#125; &#125; return myArray;&#125;var s = [5,6,7,34,45,23,12,34,14,56];for (let i = 0; i &lt; 10; i++) &#123; s = s.concat(s); // 产生一个长度为2的九次方*10的数组&#125;var start = Date.now();bubbleSort(s);var end = Date.now();console.log(&quot;排序后的数组：&quot; + s);console.log(&quot;所用时间：&quot; + (end - start)); 2. 选择排序， 原理： 找出最小的数很第一个交换位置 在剩下的数中，找出第二小的数，放在第二个位置 依次类推代码实现：123456789101112131415161718192021function selectSort(myArray) &#123; var len = myArray.length; for (let i = 0; i &lt; len - 1; i++) &#123; for(let j = i+1; j &lt; len; j++) &#123; if(myArray[j] &lt; myArray[i]) &#123; temp = myArray[i]; myArray[i] = myArray[j]; myArray[j] = temp; &#125; &#125; &#125;&#125;var s = [5,6,7,34,45,23,12,34,14,56];for (let i = 0; i &lt; 10; i++) &#123; s = s.concat(s); // 产生一个长度为2的九次方*10的数组&#125;var start = Date.now();selectSort(s);var end = Date.now();console.log(&quot;排序后的数组：&quot; + s);console.log(&quot;所用时间：&quot; + (end - start)); 看到这里是不是觉得这个测试用例好蠢 我们改进一下：1234567891011function testTime(sortFunc) &#123; var s = [5,6,7,34,45,23,12,34,14,56]; for (let i = 0; i &lt; 10; i++) &#123; s = s.concat(s); // 产生一个长度为2的九次方*10的数组 &#125; var start = Date.now(); sortFunc(s); var end = Date.now(); console.log(&quot;排序后的数组：&quot; + s); console.log(&quot;所用时间：&quot; + (end - start));&#125; 之后写好一个方法，然后调用testTime()将排序方法传进去即可 插入排序 原理： 把数组分为已排序和未排序两部分。（第一步可以第一个数为已排序，其余为未排序） 从未排序中抽出第一个数，和已排序部分进行比较，插入到合适的位置代码实现：12345678910111213function insertionSort(myArray) &#123; var len = myArray.length; for (let i = 1; i &lt; len; i++) &#123; let k; for (let j = 0; j &lt; i; j++) &#123; if(myArray[i] &lt; myArray[j]) &#123; myArray[j+1] = myArray[j]; &#125; &#125; myArray[j] = myArray[i];s &#125; return myArray;&#125;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[JS高级程序设计学习笔记]]></title>
      <url>%2F2017%2F08%2F15%2FJS%E9%AB%98%E7%BA%A7%E7%A8%8B%E5%BA%8F%E8%AE%BE%E8%AE%A1%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0%2F</url>
      <content type="text"><![CDATA[第四章两种不同数据类型的值： 基本类型值， 引用类型值基本类型值： Undefined, Null, Boolean, Number, String基本类型值在内存中占据固定大小的空间， 因此保存在栈内存中引用类型的值是对象， 保存在堆内存中 动态的属性：定义和创建接不类型值和引用类型值的方式类似: 创建一个变量并为该变量赋值只能给引用类型值动态的添加属性方法，以便将来使用 复制变量值 从一个变量向两一个变量复制基本类型值：相当于创建了一个新的值并且赋值给变量对象， 创建值的一个副本 引用类型值的赋值： 是复制了一个指针，把指针的值赋给新的变量对象 传递参数** ECMAScript中所有函数的参数都是值传递的 检测类型基本类型值的检测： typeof() 检测对象是否是字符串(string)，数值(number)， 布尔值(boolean)， 还是undefined，对于引用类型统一返回object引用类型值的检测： instanceof 语法： result = variable instanceof constructor, 在检测一个引用类型值变量跟Object构造函数时始终返回true，基本类型返回false 执行环境及作用域执行环境执行环境（环境）定义了变量或函数有权访问的其他数据，决定了他们的各自的行为。每个执行环境都有一个与之关联的变量对象，环境中定义的变量和函数都保存在这个对象中。决定了变量的生命周期 全局执行环境： 全局执行环境是最外层的执行环境 函数执行环境： 每个函数都有自己的执行环境，环境栈 作用域链当代码在一个环境中执行时，会创建变量对象的一个作用域链。环境是函数时， 活动对象（arguments）作为变量对象内部环境可以通过作用域链访问所有外部环境，但外部环境不能访问内部环境的任何变量和函数。作用域链延长：1. try-catch语句的catch, 2. with语句 没有块级作用域 声明变量： 使用var声明的变量会自动添加到最接近的环境，如果在函数中，最近的环境就是函数的局部环境。如果没有用var 声明，该变量会自动添加到全局环境（严格模式行不允许这样）。 查询标识符： 搜索从作用域前端开始， 向上逐级查询与给定标识符匹配的字符串。同名标识符局部环境的会瓶坯父环境中的标识符 垃圾回收 标记清楚 引用计数 性能问题 管理内存 解除引用： 将一个对象值设置为null，作用是让其脱离执行环境，以便垃圾收集器下次将他回收。 第五章 引用类型引用类型值（对象）是引用类型的一个实例： 对象是某个特定引用类型的实例， 新对象使用new操作符后跟一个构造函数来创建的。构造函数本身就是一个函数，只是出于创建新对象的目的定义的。 Object类型 两种创建方式： new 操作符后跟Object构造函数 123var person = new Object();person.name = &quot;nico&quot;;person.age = 29; 对象字面量表示法： 1234var person = &#123; name: &quot;nico&quot;, age: 29&#125;; 对象属性的访问： 点表示法，如：person.age; 方括号表示法： 如： person[“name”]; Array 两种创建方式： new 加Array构造函数 123var colors = new Array();var colors1 = new Array(3); // 创建一个包含三项的数组var name = new Array(&quot;Grey&quot;); // 创建一个包含一项的数组 数组字面量法： 123var colors = [&quot;red&quot;, &quot;blue&quot;];var names = []; // 空数组var values = [1, 2,]; // 不要这样这样会创建一个2项或者三项的数组 数组读取： 读取和设置数组的值时， 使用方括号和基于0的数字索引： colors[1] = “black”;数组的length, 不止可读，也可以进行设置 检测数组 value instanceof Array 有局限性： 只能用于单一的全局执行环境 Array.isArray(value) (ECMAScript5 新增) 转换方法每个对象都有toLocaleString(), toString(), valueOf()方法数组继承的这三个方法，在默认情况下都会以逗号分隔的字符串形式返回数组项join()方法可以使用不同的分隔符来构建这个字符串 colors.join(“||”);如果数组的某一项值时null或者undefined，那么在返回的结果中以空字符串表示 栈方法栈是一种LIFO(Last-In-First-Out)后进先出的数据结构，栈的插入（推入）和移除（弹出）只发生在栈顶ECMAScript为数组提供了push(), pop()来实现栈方法 队列方法队列数据结构访问规则：FIFO(First-In-First-Out)先进先出，队列在队尾添加项， 在队头移除项通过push(), shift()来实现队列方法通过unshift(), pop()来反向模拟队列 重排序方法reverse()反转数组项的顺序sort()给数组排序，默认按升序排序数组, 默认是比较字符串，将数组每一项都转化成字符串然后比较sort()可以接受一个比较函数，比较函数接受两个参数，如果第一个参数应该在第二个参数之前就返回一个负数，相等返回0，第一个参数应该位于第二个参数之后返回1。 操作方法concat() 拼接数组，原数组不变，生成一个拼接后的数组slice() 基于当前数组的一项或者多项创建一个数组，相当于截取数组，接受两个参数：返回项的起始位置和结束位置，第二个参数省略的话就是默认数组结尾，有参数的话不包含结束位置的这一项splice() 最强的数组操作方法，可用于： 删除： 两个参数，要删除的第一项的位置和删除的项数 插入： 三个参数，起始位置，0（表示不删除）， 要插入的项 替换： 三个参数，起始位置， 要删除的项数， 插入的项 位置方法indexOf(): 从数组的开头向后查找lastIndexOf(): 从数组的末尾向前查找上边两个方法有两个参数： 要查找的项，（可选的）表示查找起点位置的索引 迭代方法ECMAScript5为数组定义了5个迭代方法，每个方法接受两个参数： 要在每一项上运行的函数， （可选的）运行该函数的作用域对象而这个作为参数的函数一般有三个参数，数组项的值，该项在数组的位置和数组对象本身 every(): 对数组中每一项运行给定函数，如果该函数对每一项都返回true，则返回true filter(): 对数组中每一项运行给定函数，返回该函数能够返回true的项构成的数组 forEach(): 对数组中每一项运行给定函数, 没有返回值 map(): 对数组中每一项运行给定函数, 返回每次函数调用结果组成的数组 some(): 对数组中每一项运行给定函数, 如果有一项该函数返回true就返回true12345var numbers = [1, 2, 3, 4];var result = numbers.map(function(item, index, array)&#123; return item * 2;&#125;);alert(result); // [2, 4, 6, 8] 缩小方法 方法 作用 返回值 push() 在数组末尾添加项 修改后的数组长度 pop() 从数组末尾移除最后一项 移除的项 shift() 移除数组中的第一项 移除的项 unshift() 在数组前端添加项 修改后的数组长度 reverse() 反转数组项的顺序 反序后的数组 sort() 数组排序 排序后的数组]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[学习总结]]></title>
      <url>%2F2017%2F08%2F13%2F%E5%9F%BA%E6%9C%AC%E7%9F%A5%E8%AF%86%E6%80%BB%E7%BB%93%2F</url>
      <content type="text"><![CDATA[雅虎34条页面优化法则 尽量减少HTTP的请求次数： 合并文件，CSS Sprites, 图片地图， 内联图像 减少DNS查找次数 避免跳转 可缓存的AJAX 推迟加载内容 预加载 减少DOM元素数量 根据域名划分页面内容 使iframe的数量最小 不要出现404 使用内容分发网站 为文件头指定EXpirse或Cache-control Gzip压缩文件内容 配置Etag 尽早刷新输出缓冲 使用GET完后AJAX请求 吧样式表置于顶部 避免使用CSS表达式 使用外部JS和CSS 消减JS和CSS 用 代替@import 避免使用滤镜 将脚本置于页面底部 删除重复脚本 减少DOM访问 开发智能事件处理程序 减少Cookie体积 对于页面内容使用无Cookie域名 优化图像 优化CSS sprite 不要子啊HTML中缩放图像 favicon.ico要小且可缓存 保持单个内容小于25K 打包组件成复合文本 从输入URL到页面加载完后经历了什么 浏览器接受URL， URL的信息包括： 协议， 网络地址：端口号， 资源路径， 查询字符串？， 片段标识符# 将URL与缓存进行对比，如果请求页面在缓存中且未过期，直接进行第八步缓存分为彻底缓存和协商缓存，这里的是否过期指定是彻底缓存 - 彻底缓存的机制HTTP首部字段： cache-control Expires Expires是一个绝对事件即服务器时间（现已很少用） cache-control中的max-age 保存一个相对时间，如Cache-Control: max-age = 48420, 表示缓存在48420s内有效cache-control还有其他指令： cache-control还有其他指令： （ 请求/响应指令） no-cache,使用缓存前必须和服务器进行确认，也就是需要发起请求。 no-store,不缓存； （响应指令） public，缓存文件保存在缓存服务器上，且其他用户也可以访问； private，只有特定用户才能访问该缓存资源。 - 缓存协商当缓存过期时， 浏览器会向服务器发起请求询问资源是否真的过期这就是缓存协商HTTP首部字段： last-modified Etag last-modified是第一次请求资源时， 服务器返回的字段，表示最后一次更新的时间。下一次浏览器请求资源时就发送if-modified-since字段。服务器用本地Last-modified时间与if-modified-since时间比较，如果不一致则认为缓存已过期并返回新资源给浏览器；如果时间一致则发送304状态码，让浏览器继续使用缓存。当然，用该方法也存在问题，比如修改时间有变化但实际内容没有变化，而服务器却再次将资源发送给浏览器。所以，使用Etag进行判断更好。 Etag 资源的实体标识（哈希字符串），当资源内容更新时，Etag会改变。服务器会判断Etag是否发生变化，如果变化则返回新资源，否则返回304。 缓存协商的过程需要发起一起HTTP请求，如果返回304则继续使用缓存。对于移动端一次请求还是有代价的，所以我们需要避免304。对于很少进行更改的静态文件，可以在文件名中加入版本号，如get.v1.js，并且把Cache-Control的max-age设置成一年半载，这样就不会发送请求。需要注意的是，当这些文件更新的时候，我们需要更新其版本号，这样浏览器才会到服务器下载新资源。 DNS解析：网络地址不是IP地址，通过DNS解析域名返回一个IP地址3.1 DNS协议： DNS数据库是域名和IP地址相互映射的一个分布式数据库，DNS协议用来将域名转换为IP地址，它运行在UDP协议之上。为什么选择UDP而非TCP？原因如下：UDP无需连接，时效性更好，进行一次查询只需要两个DNS包。而TCP需要先用3个包建立连接，再用2个DNS包进行查询，最后用4个包断开连接，连接成本远大于查询本身，容易让DNS服务器不堪重负。3.2 DNS查询： 操作系统会先检查本地hosts文件是否有这个网址映射关系，如果有就调用这个IP地址映射，完成域名解析。 否则，查找本地DNS解析器缓存，如果查找到则返回。 否则，查找本地DNS服务器，如果查找到则返回。 否则，1）未用转发模式，按根域服务器 -&gt;顶级域,.com-&gt;第二层域，example.com -&gt;子域，www.example.com的顺序找到IP地址。2）用转发模式，按上一级DNS服务器-&gt;上上级-&gt;….逐级向上查询找到IP地址。 浏览器和服务器通过三次握手建立TCP链接 浏览器向服务器发送HTTP请求 服务器接收到请求，从它的文档空间中查找资源并饭会HTTP响应 浏览器接受HTTP响应，根据HTTP header里的状态码，做出处理1XX 表示消息2XX 表示成功3XX 表示重定向4XX 表示请求错误5XX 表示服务器端错误常见状态码：200 OK表示请求成功 一切正常301 Moved Permanently重定向，客户请求的文档在其他地方，新的URL在Location头中给出，浏览器应该自动地访问新的URL302 Found临时重定向，类似于301，但新的URL应该被视为临时性的替代，而不是永久性的。304 Not Modified客户端有缓冲的文档并发出了一个条件性的请求。服务器告诉客户，原来缓冲的文档还可以继续使用。400 Bad Request请求出现语法错误。403 Forbidden资源不可用。404 Not Found无法找到指定位置的资源。405 Method Not Allowed请求方法（GET、POST、HEAD、Delete、PUT、TRACE等）对指定的资源不适用。500 Internal Server Error服务器遇到了意料不到的情况，不能完成客户的请求。501 Not Implemented服务器不支持实现请求所需要的功能。 如果是可以缓存的，这个响应则会被存储起来。 解码9.1 浏览器拿到index.html文件后，就开始解析其中的html代码，遇到js/css/image等静态资源时，就向服务器端去请求下载9.2 解析成对应的树形数据结构DOM树、CSS规则树，Javascript脚本通过DOM API和CSSOM API来操作DOM树、CSS规则树。 渲染10.1 计算CSS样式（JS可动态修改dom或css,进一步改变渲染树和分布）10.2 构建渲染树（Repaint：屏幕的一部分要重画，比如某个CSS的背景色变了，元素的几何尺寸没有变。Reflow：几何尺寸变了，我们需要重新验证并计算Render Tree。）10.3 确认布局（定位坐标和大小，是否换行，各种position, overflow, z-index属性 ……）10.4 绘制（调用操作系统Native GUI的API绘制，将每个节点转化为实际像素绘制到视口上） 关闭TCP链接或者继续保持连接通过四次挥手关闭连接(FIN ACK, ACK, FIN ACK, ACK)。 百度面试注重基础 extend是继承，如何自己用原生JS实现继承 =&gt;函数与普通匿名函数的区别（this） CSS选择器的权重 转载和借鉴：作者：minxuan链接：http://www.jianshu.com/p/71cf7f69eca8]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[JS 字符串操作]]></title>
      <url>%2F2017%2F08%2F12%2FJS%20%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%93%8D%E4%BD%9C%2F</url>
      <content type="text"><![CDATA[JS自带函数1. concat将两个或多个字符的文本组合起来，返回一个新的字符串。var a = “hello”;var b = “,world”;var c = a.concat(b);alert(c);//c = “hello,world” 2. indexOf返回字符串中一个子串第一处出现的索引（从左到右搜索）。如果没有匹配项，返回 -1 。var index1 = a.indexOf(“l”);//index1 = 2var index2 = a.indexOf(“l”,3);//index2 = 3 3. charAt返回指定位置的字符。var get_char = a.charAt(0);//get_char = “h” 4. lastIndexOf返回字符串中一个子串最后一处出现的索引（从右到左搜索），如果没有匹配项，返回 -1 。var index1 = lastIndexOf(‘l’);//index1 = 3var index2 = lastIndexOf(‘l’,2)//index2 = 2 5. match检查一个字符串匹配一个正则表达式内容，如果么有匹配返回 null。var re = new RegExp(/^\w+$/);var is_alpha1 = a.match(re);//is_alpha1 = “hello”var is_alpha2 = b.match(re);//is_alpha2 = null 6. substring返回字符串的一个子串，传入参数是起始位置和结束位置。var sub_string1 = a.substring(1);//sub_string1 = “ello”var sub_string2 = a.substring(1,4);//sub_string2 = “ell” 7. substr返回字符串的一个子串，传入参数是起始位置和长度var sub_string1 = a.substr(1);//sub_string1 = “ello”var sub_string2 = a.substr(1,4);//sub_string2 = “ello” 8. replace用来查找匹配一个正则表达式的字符串，然后使用新字符串代替匹配的字符串。var result1 = a.replace(re,”Hello”);//result1 = “Hello”var result2 = b.replace(re,”Hello”);//result2 = “,world” 9. search执行一个正则表达式匹配查找。如果查找成功，返回字符串中匹配的索引值。否则返回 -1 。var index1 = a.search(re);//index1 = 0var index2 = b.search(re);//index2 = -1 10. slice提取字符串的一部分，并返回一个新字符串（与 substring 相同）。var sub_string1 = a.slice(1);//sub_string1 = “ello”var sub_string2 = a.slice(1,4);//sub_string2 = “ell” 11. split通过将字符串划分成子串，将一个字符串做成一个字符串数组。var arr1 = a.split(“”);//arr1 = [h,e,l,l,o] 12. length返回字符串的长度，所谓字符串的长度是指其包含的字符的个数。var len = a.length();//len = 5 13. toLowerCase将整个字符串转成小写字母。var lower_string = a.toLowerCase();//lower_string = “hello” 14. toUpperCase将整个字符串转成大写字母。var upper_string = a.toUpperCase();//upper_string = “HELLO”]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[工作总结]]></title>
      <url>%2F2017%2F08%2F12%2F%E5%B7%A5%E4%BD%9C%E6%80%BB%E7%BB%93(Nobook)%2F</url>
      <content type="text"><![CDATA[工作技能掌握 Node.js的fs文件系统， JSON与js对象的相互转换（parse，stringily） CSS的pointer-events（穿透） JS的apply 跟call JS的apply跟call每个函数都包含两个非继承来的方法：apply()跟call()。这两个方法都是在特定的作用域中调用函数，实际等于设置函数体内的this的=对象的值。apply(): 接受两个参数：1.在其中运行函数的作用域 参数数组：可以是Array的实例，也可以是arguments对象call():接受两个以上的参数，第一个参数是作用域，其余的所有参数直接传给对象。就是原来传递给函数的参数要罗列出来。 CSS的pointer-eventsPointer-events 字面意思是惦记鼠标事件，值常用的是auto 跟nonepointer-events: none; 表示它将捕获不到任何点击，让事件穿透到它的下面。pointe-events: auto; 默认值，将会捕获在这上边的事件。 JSON与js对象的相互转换首先看看JSON对象和JSON字符串的区别：JSON对象类似于JS对象，只是要对属性的使用“”双引号。而JSON字符串是在JSON对象外加上双引号。在数据传输过程中，json是以文本，即字符串的形式传递的，而JS操作的是JSON对象，所以，JSON对象和JSON字符串之间的相互转换是关键。看代码：下边看转化：JSON字符串转化为JSON对象，调用parse方法：Var jsonObj = JSON.parse(jsonStr);JSON对象转化为JSON字符串，调用stringily方法：Var jsonStr = JSON.stringify(jsonObj); 知识总结 jsfl使用flash_cs5_extengding.pdf来查看怎样书写代码和使用。 bit-101 flash actionScript 动画教程 flash actionScript 动画教程.pdf jQuery 的bind()用来绑定事件，绑定事件的格式为$(‘#button’).bind(‘click’, function(){ … }); unbind()解除通过bind绑定的事件，格式为$(‘#button’).bind(‘click’,function(){ … }); [jQuery 的事件命名空间]： (http://www.cnblogs.com/lyzg/p/5347857.html)]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[第五章 增强可访问性]]></title>
      <url>%2F2017%2F08%2F10%2FHTML5-CSS-5%2F</url>
      <content type="text"></content>
    </entry>

    
    <entry>
      <title><![CDATA[JQuery廖雪峰学习笔记]]></title>
      <url>%2F2017%2F08%2F07%2FJQuery%2F</url>
      <content type="text"><![CDATA[JQuery使用在head中直接引用JQuery文件$是JQuery符号，JQuery把所有功能全部封装在一个全局变量JQuery中，而$就是JQuery的别名。JQuery（$）本质上是一个函数，因此也是一个对象，$除了直接调用还有其他的属性。这里说一句，JQuery采用这种方式将他的方法和属性都包装到一个函数中，保护了他的属性和方法对外隐藏，是JS闭包的一种运用。 选择器选择器是JQuery的核心，其实JQuery的选择器很像CSS的格式 JS的DOM操作 JQuiery的DOM操作 document.getElementById(‘idName’) $(‘#idName’) document.getElementsByTagName(‘tagName’) $(‘tagName’) document.getElementsByClassName(‘className’) $(‘.className’) 通过$()查询返回的都是JQuery对象，JQuery对象类似数组，他的每个元素应用了DOM节点对象1 如果查询的id不存在，返回[], 因此JQuery的选择器不会返回undefined或者null，JQuery的强大之处在于可以按照属性进行查找：123var email = $(&apos;[name = email]&apos;);var psd = $(&apos;[type = password]&apos;);var J = $(&apos;[属性 = 属性值]&apos;); 当然你还可以使用正则进行这样的查询:12var icons = $(&apos;[name ^= icon]&apos;); ////找出所有name属性值以icon开头的DOMvar names = $(&apos;[name $= waith]&apos;); ////找出所有name属性值以with结尾的DOM 这个方法适合通过class属性进行查找，且不受包含多个class名称的影响1var icons = $(&apos;[class ^= &quot;icon-&quot;]&apos;); //// 找出所有class包含只少一个以icon-开头的DOM 也可以进行组合查找:12var emailInput = $(&apos;input[name=email]&apos;);var tr = $(&apos;tr.red&apos;); 还可以用,隔开进行组合一块选择：1$(&apos;p, div&apos;); //// 把&lt;p&gt;和&lt;div&gt;都选出来 DOM对象和JQuery对象转化DOM对象转换为JQuery对象： $(aDomObject); 这样就可以调用JQuery的API了 JQuery对象转换为DOM对象： JQueryObj.get(index)获得数组中的一个DOM对象 选择器 例子 层级选择器 空格隔开 $(‘ul p input’) 子选择器 &gt; 隔开 $(parent&gt;child) 过滤器 选择器 作用 :first-child 选择第一个节点 :last-child 选择最后一个节点 :nth-child(n) 选择第n个节点,N从以开始 :nth-child(odd) 选择序号为奇数的节点元素 :nth-child(even) 选择序数为偶数的节点元素 查找和过滤查找 在当前节点的子节点中进行查找，用find()方法，find本身能接受任意一种选择器 从当前节点向上查找，用parent()方法 对于同一级的节点，用next()和prev()方法过滤 filter()方法可以过滤掉不符合选择器的节点，参数可以是一个函数，函数内部的this被绑定为DOM对象而不是JQuery对象 map()方法把一个JQuery对象包含的若干个DOM节点转化为其他对象 如果JQuery对象包含了不止一个DOM节点，first(), last()和slice()方法可以返回一个新的JQuery对象 操作DOM修改Text和HTMLjQuery对象的text()和html()方法分别获得节点的文本和原始的HTML文本，如果无参调用就是获取，传入参数就变成了设置文本。由于JQuery对象可以包含多个或者0个DOM对象，所以操作是在一组DOM对象上进行的，同样即使没有DOM对象也不会报错 修改CSSJQuery的‘批量操作’使得修改CSS很方便，调用JQuery对象的方法css(‘name’, ‘value’)，而且支持链式操作css()方法将作用于DOM节点的style属性，具有高优先级。修改class属性可以采用以下方法：jQueryObj.hasClass(‘className’); // 判断是否包含jQueryObj.addClass(‘className’); // 添加classjQueryObj.removeClass(‘className’); // 删除class 显示和隐藏DOM隐藏一个DOM可以设置CSS的属性display属性为none,但是显示的时候要知道之前的display属性，而JQuery直接提供了show()和hide()方法，隐藏了修改display的细节显示和隐藏DOM不改变DOM数的结构 获取DOM信息 通过jQuery对象的若干方法可以直接获得DOM的宽高信息// 浏览器可视窗口的大小$(window).width();$(window).height();// HTML文档的大小$(document).width();$(document).height();// 某个DIV的大小var div = $(‘#test-div’);div.width();div.height();div.width(400);div.height(‘200px’); // 设置CSS属性，是否生效要看CSS是否有效 attr()和removeAttr()用于操作DOM节点的属性 1234567// &lt;div id = &quot;test-div&quot; name = &quot;Test&quot; start=&quot;1&quot;&gt; ... &lt;/div&gt;var div = $(&apos;#test-div&apos;);div.attr(&apos;data&apos;); // undefined 属性不存在div.attr(&apos;name&apos;); // &apos;Test&apos;div.attr(&apos;name&apos;, &apos;Hello&apos;); // div的name属性变成了&apos;hello&apos;;div.removeAttr(&apos;name&apos;); // 删除name属性div.attr(&apos;name&apos;); // undefined prop()跟attr()类似，但是对于那种在节点中没有值，只有出现和不出现的属性例如 checked 123var radio = $(&apos;#test-radio&apos;);radio.attr(&apos;checked&apos;); // &apos;checked&apos;radio.prop(&apos;checked&apos;); // true 不过对于这种属性，用is最好 radio.is(‘:checked’); // true 类似的属性有selected is(‘:selected’) 操作表单对于表单元素，JQuery对象提供val()方法获取和设置对应的value属性，无参是获取，传入参数是设置 修改DOM结构添加DOM节点添加DOM节点除了使用html()这种暴力的方法外，还可以用append()方法，调用append()传入HTML片段（append()是添加子节点在最后）12var ul = $(&apos;#test-div&gt;ul&apos;);ul.append(&apos;&lt;li&gt;&lt;span&gt;Hask&lt;/span&gt;&lt;/li&gt;&apos;); append()除了接收字符串，还可以传入原始的DOM对象，JQuery对象和函数对象，传入函数时， 要求返回一个字符串，DOM对象或者JQuery对象。因为JQuery对象可能是一组DOM对象，只有传入函数才能针对不同的DOM对象生成不同的子节点prepend()把DOM添加在最前面after()和before()方法用于同级节点 删除节点remove()方法删除jQuery对象包括的所有DOM节点 事件由于浏览器绑定事件的方法不同，JQuery来写代码就屏蔽了浏览器的差异on()用来绑定一个事件，传入事件名称和对应的处理函数，也可以直接调用事件方法a.on(‘click’, function(){alter(‘Hello!’);}); 等价于 a.click(function(){alter(‘Hello!’);});jQuery 能够绑定的事件如下 鼠标事件click: 鼠标点击时触发;dbclick: 鼠标双击时触发;mouseenter: 鼠标进入时触发;mouseleave: 鼠标移开时触发;hover: 鼠标进入和移开时触发两个函数，相当于mouseenter加上mouseleave 键盘事件键盘事件仅作用于当前焦点的DOM上，通常是&lt;input&gt;和&lt;textarea&gt;keydown: 键盘按下时触发keyup: 键盘松开时触发keypress: 按一次键后触发 其他事件focus: 当DOM获得焦点时触发;blur: 当DOM失去焦点时触发;change: 当&lt;input&gt; &lt;textarea&gt; &lt;select&gt; 的内容发生改变时触发;submit: 当 &lt;form&gt;提交时触发;ready: 当页面被载入并且DOM树完后才能初始化后触发; 仅作用于document对象 ready事件在DOM完成初始化后触发，且触发一次。适合用来写其他的初始化代码$(docement).on(‘ready’, function () { … ;}); 等价于 $(document).ready(function (){ … ;}); 等价于 $(function () {}); 事件参数有些事件，如mousemove和keypress, 我们需要获得鼠标的位置和按键的值，这些事件都会传入Event对象作为参数，可以从Event对象上获得更多的信息12345$(function() &#123; $(&apos;#testMouseMove-div&apos;).mousemove(function(e) &#123; $(&apos;#testMouseMove-span&apos;).text(&apos;PageX = &apos; + e.pageX + &apos;, PageY = &apos; + e.pageY); &#125;)&#125;); 取消绑定通过off(‘click’, function)实现，移除的函数必须跟绑定的函数是同一个，如果是匿名函数就无法移除，可以使用off(‘click’)一次性移除已绑定的click事件的所有处理函数同理无参调用off()一次性移除已绑定所有类型的事件处理函数 事件触发条件事件的触发是通过用户操作引起的，如果我们通过JS代码去修改文本框的内容将不会触发change事件；如果希望用代码触发change事件，可以直接调用无参数的change()方法来触发该事件： input.val(‘change it’); input.change(); input.change() 相对于 input.trigger(‘change’), 它是trigger()方法的简写 浏览器安全限制在浏览器中有些JS代码只有在用户的触发下才能执行。例如window.open()函数 在JSdiamante中是不会被执行的，只有通过用户事件进行触发 动画这里我在工作中用的是Tween一系列的js库，感兴趣的可以关注我之后的文章更新。 这里介绍jQuery内置的几种动画 show()和hide(),无参调用show()和hide()会显示和隐藏DOM元素，但是，传入一个时间参数，就变成了动画。如 show(3000); // 在3秒内逐渐显示时间以ms为单位，但也可以是’slow’(0.6) ‘fast’这些字符串 show()和hide()是从左上角逐渐展开或者收缩的 toggle()方法根据当前状态决定是show()还是hide() slideUp()和slideDown()在垂直方向上逐渐展开或者收缩的slideUp()把一个DOM元素收起来，slideDown()相反，而slideToggle()是根据元素是否可见进行下一步操作的 fadeIn()和fadeOut()的动画效果是淡入淡出，也就是通过不断地设置DOM元素的opacity属性来实现的 fadeToggle()根据当前状态决定下一步操作自定义动画animate()可以实现任意动画效果，需要传入的参数就是DOM元素的最终CSS状态和时间123456var div = $(&apos;#test-div&apos;);div.animate(&#123; opacity: 0.25; width: &apos;256px&apos;; height: &apos;256px&apos;;&#125;, 3000); animate()还可以接受第三个参数，参数是一个回调函数，当动画结束时这个动画被调用12345678var div = $(&apos;#test-div&apos;);div.animate(&#123; opacity: 0.25; width: &apos;256px&apos;; height: &apos;256px&apos;;&#125;, 3000， function()&#123; console.log(&apos;动画结束&apos;);&#125;); 串行动画jQuery的动画可以串行执行，通过delay()方法还可以实现暂停， 这样我们可以实现复杂的动画效果123456789101112var div = $(&apos;#test-animates&apos;);div.slideDown(2000) .delay(1000) .animate(&#123; width: 200px; height: 256px; &#125;, 2000) .delay(1000) .animate(&#123; width: 100; height: 128; &#125;, 2000) 动画执行需要时间所以JQuery不断地返回新的Promise对象才能执行后续操作。 其他问题有时候动画没有效果， 是因为你执行动画的那个DOM元素不是块级元素可能有些属性没有。此外JQuery也没有实现background-color的动画效果，可以通过CSS3的transition实现动画效果。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[2017年中个人总结]]></title>
      <url>%2F2017%2F08%2F07%2Fpersonal-summary%2F</url>
      <content type="text"><![CDATA[2017年中个人总结 不知不觉离职已经有两周了，从15年毕业到现在过去了将近两年的时间。我是一个而不擅长写总结的人，总觉得有点矫情。就像我不爱拍照一样，我希望生活是亲身去经历和用眼镜去观察，而不是惨白的文字和冰冷的照片所记录。这样难免有些浑浑噩噩，不知己所求。所以以史为鉴不是没有道理，因此在这里写下自己的总结，希望能够养成这样的习惯：每一年写一个年度总结。 15年刚毕业那会，自己很迷茫，大学成绩一般，兴趣爱好不明。大一大二还认真听课，学习基础知识，参加一些社团活动。大三大四开始松懈，打篮球崴到脚之后，在寝室没事打游戏看看电影。不过好在每次考前都会认真的将课本看一遍所以没有挂过科，顺利的毕业了。其中想考过研，后来觉得像早一点进入社会就放弃了考研。那段时间包括现在都很迷茫跟自卑，不知道自己想要什么，能做什么。错过了互联网大公司的校园招聘，这个真的很遗憾。我觉得大学生大三下学期如果确定要步入社会，一定要做好职业规划和提前了解大公司的校招信息。因为那个时候你有应届毕业生这个条件，公司可以允许你没有经验。因此一定要抓住应届的机会。 大四上学期去一家游戏公司实习，工作强度大概是996吧，实习期工资好像是一天120。那两个月还比较充实，但是总是感觉公司比较乱，结构总在调整，而且感到自己不是很感兴趣，所以没有留下。毕业时想找一家加班少的公司，因此在学校的招聘会上投了一家外企公司L。后来在这家公司呆到今年4月。在L期间，作一些自动化测试脚本的维护跟数据分析模块的代码维护，工作强度不大，然后福利待遇特别好，遇见一群很可爱的同事，能够一起打篮球吃饭吹逼。后来看了一些毒鸡汤说什么年轻人不应该选择安逸要努力奋斗，就开始自学前端知识，准备跳槽做前端。因为自己感觉JS语言的发展空间很大，而且自己也想挑战一下自己，跳出自己的舒适区。 四月份开始找前端工作，那时候很着急希望早点找到一个要我的公司，能够把自己学的知识转化成实际的项目中去，增加自己的项目经验。所以很匆忙，当时就面试了一两家公司，就决定去N。在组长给谈升职加薪的时候提出了离职，确实有点不礼貌，心里也一直觉得对不起。组长人很好表示了挽留，但是我还是毅然决定出去看看外边，愧疚更深。其实当时面试的两家公司都决定要我，而我选择N的原因是N公司面试我的组长看起来更厉害。来到N之后，跟L区别太大了，这是一个创业公司，大家都很卖命，也许是自己不熟，感觉大家都在自己忙自己的，很少交流。因为我是刚入行，所以比别人压力更大，压力大造成自己不够自信，不自信又造成自己做事慢，被组长各种催，恶性循环。大概失眠了一周左右，那段时间晚上一闭眼就是各种动画效果和代码逻辑。大概有一个月的事件自己慢慢的跟上了公司的节奏，代价是瘦了将近10斤。后来就是高强度的搬砖，大概8点半到公司坐到晚上九点半，期间不怎么离开座位，可能是脖子落枕了还是怎么的左胳膊发麻，去医院看看了没啥毛病多运动就好了。三个月试用期结束的时候，其实自己就在考虑准备换一个公司，自己身体扛不住这么高强度的运转，可是没什么理由，而且在项目刚走向正规，自己也越来越得心应手，所以没敢说离职的想法。可是这时候人力跟组长找我谈话，说要延长试用期，我想着就借这个机会直接离职吧。后来人力同意直接转正，可是已经有了这次隔阂，我想想还是算了。就离职回家静养了一周。 从七月底休息到现在，更新了自己之前的一些技术学习的笔记，总结了这一段自己的学习所得。然后现在准备找工作，这次希望进一个大公司，因为大公司可能规范一些，而且换工作真的身心疲惫，这次一定要确定好一家公司然后干到他倒闭，不倒闭就一直干下去。哈哈，开玩笑了，不过这次如果找到合适的真的就不想在折腾自己了。目前掌握了Tween等JS动画库，了解了PIXI.js， there.js等引擎，了解了粒子效果。对webGL和H5的canvas有了更深的了解。这段时间的计划是在找工作的同时， 学习最新的vue和react框架，学习JS设计模式，巩固之前学习的JQuery跟Angular。最重要的是锻炼身体和调整自己的心情，目前还是比较悲观，希望能走出来变得而更加积极。 愿你走出半生，归来仍是少年。（这篇文章只是个人总结，没啥干货也没啥好转载的）]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[廖雪峰JS学习笔记2]]></title>
      <url>%2F2017%2F08%2F05%2FJS_Liao-2%2F</url>
      <content type="text"><![CDATA[浏览器对象Windowwindow对象不仅充当全局作用域，并表示浏览器窗口 window对象有innerWidth 和 innerHeight 属性，获得浏览器窗口的内部宽和高 outerWidth和outerHeight属性，可以获取整个浏览器的宽高 navigator 对象表示浏览器的信息，常用的属性：navigator.appName: 浏览器名称 navigator.appVersion: 浏览器版本 navigator.language 浏览器设置的语言 navigator.platform: 操作系统类型 navigator.userAgent: 浏览器设定的User-Agent字符串 screen 表示屏幕信息 常用属性：screen.width: 屏幕宽度，以像素为单位 screen.height: 屏幕高度，以像素为单位 screen.colorDepth: 返回颜色位数 location 表示当前页面的URL信息一个完整的URL： &gt; http://www.example.com:8080/path/index.html?a=1&amp;b=2#TOP 可以用location.href获取。要获得URL各个部分的值，可以这么写： 123456location.protocol; // &apos;http&apos;location.host; // &apos;www.example.com&apos;location.port; // &apos;8080&apos;location.pathname; // &apos;/path/index.html&apos;location.search; // &apos;?a=1&amp;b=2&apos;location.hash; // &apos;TOP&apos; 要加载一个新页面，可以调用location.assign()。如果要重新加载当前页面，调用location.reload()方法非常方便。 document 对象表示当前页面，整个DOM树的根节点###### document.title 改变标题 查找DOM树的某个节点：从document对象开始查找，最常用的就是根据ID和Tag Name document.getElementById(), getElementsByTagName() ###### document 还有一个cookie属性，可以获得当前页面的cookie history 对象保留了浏览器的历史记录，JS可以调用history的back()和forward()history对象不建议使用 更新DOM##### 修改节点的文本方法有两种： ###### 1.修改innerHTML属性：即可修改一个DOM节点的文本内容，也可以通过HTML片段修改DOM节点内部的子树 ###### 2. 修改innerText或textContent属性，直接对字符串进行HTML编码，无法设置任何HTML标签 在读取属性时，innerHTML不返回隐藏的文本，而textContent返回所有文本，IE&lt;9不支持textContent DOM节点的style属性对应所有的CSS，fontSize对应CSS中的font-size 插入DOMinnerHTML会替换原来的所有节点，所以插入节点有两个其他方法： 1.appendChild() 把一个子节点添加到父节点的最后一个子节点 动态创建一个节点然后添加到DOM树种可以实现很多功能：添加CSS格式： 1234var d = document.createElement(‘style’);d.setAttribute(‘type’, ‘text/css’);d.innerHTML = ‘p &#123; color: red &#125;’;document.getElementsByTagName(‘head’)[0].appendChild(d); 2. insertBefore 把子节点插入到指定位置 用法： parentElement.insertBefore(newElement, referenceElement); 子节点会插入到referenceElement 之前 循环一个父节点的所有子节点通过迭代children属性实现： 12345var i, c,list = document.getElementById(‘list’);for (i = 0; i &lt; list.children.length; i++) &#123; c = list.children[i];&#125; 删除DOM删除节点需要获得该节点本身跟他的父节点，调用父节点的removeChild把自己删掉 删除的节点虽然不在文档树中，但其实他还在内存中，可以随时被添加到别的位置 children属性是一个只读属性，并且它在子节点变化时会时时更新，因此删除多个节点时，children属性时刻都在变化 操作表单用JS操作表单和操作DOM一样， JS操作表单可以获得用户的输入或者对一个输入框设置新的内容 表单控件：* 文本框，&lt;input type = “text”&gt; 用于输入文本 * 口令框， &lt;input type = “password”&gt; 用于输入口令 * 单选框， &lt;input type = “radio”&gt; 用于选择一项 * 复选框，&lt;input type = “checkbox”&gt; 用于选择多项 * 下拉框，&lt;select&gt; 用于选择一项 * 隐藏文本， &lt;input type = “hidden”&gt; 用户不可见，但表单提交时会把隐藏文本发送到服务器 获取值首先获得节点的引用， 然后调用**value**获得对应的用户的输入值，对于radio 和 checkbox 获得是否勾选通过**checked**进行判断 设置值和获取值类似，对于text , password, hidden, select 直接设置**value** 对于radio和checkbox，设置**checked** 为true或者false即可 HTML5控件新增常用： date, datetime, datetime-local, color等，他们都是用&lt;input&gt;标签 如： &lt;input type = “date” value = “2015-07-01”&gt; 提交表单两种方式： * 1.通过**form**元素的submit()方法提交表单 * 2.浏览器默认点击&lt;button type = “submit”&gt;时提交表单，或者是在最后一个输入键按回车，因此可以通过相应&lt;form&gt;本身的onsubmit事件。onsubmit = “return checkForm()” 12345678910111213&lt; form id = “login=form” methon = “post” onsubmit = “return checkForm()”&gt; &lt;input type = “text” id = “username” name = “username”&gt; &lt;input type = “password” id = “input-password”&gt; &lt;input type = “hidden” id = “md5-password&quot; name = “password”&gt; &lt;button type = “submit”&gt;Submit&lt;/button&gt;&lt;/form&gt;&lt;script&gt; function checkForm() &#123; var input_pwd = document.getElementById(‘input-password’); var md5_pwd = document.getElementById(‘md5-password’); md5_pwd.value = toMD5(input_pwd.vaule); return true; &#125; Type为hidden用户不可见， 同时因为设置了name属性的&lt;input&gt;的数据会被提交，没有name属性的就不会被提交。 操作文件上传文件的唯一控件 type = “file”> ```1234567891011121314151617 ** 注意： 当一个表单包含``` &lt;input type = “file”&gt; ```时，表单的enctype必须制定为multipart/form-data, method必须指定为post， 浏览器才能正确的编码并且以multipart/form-data格式发送表单数据 ** 浏览器只允许选择本地文件因此不能通过改变value的方式来改变文件路径，也不能获得文件的真实路径 #### File API 新增的file API 允许JS获取文件内容，H65新增的File API主要有File和FIleReader两个主要对象 ### AJAX AJAX并不是JS的规范， 他是Asynchronous JavaScript and XML 意识就是用JS执异步网络请求。 Web 运作原理： 一次HTTP请求对应一个页面 而AJAX请求时异步的，要通过回调函数获得响应 现在浏览器上写AJAX主要依靠XMLHttpRequest对象 var request = new XMLHttpRequest(); // 新建XMLHttpRequest对象 Request.onreadystatechange = function() &#123; 状态发生变化时， 函数被回调 &#125; 低版本的IE使用ActiveXObject对象 Var request = new ActiveXObject(‘Microsoft.XMLHTTP’); 通用：var request; if (window.XMLHttpRequest) { request = new XMLHttpRequest(); } else { request = new ActiveXObjext(&apos;Microsoft.XMLHTTP&apos;); // 针对低版本IE } ``` 创建对象后，首先设置onreadystatechange的回调函数，在回调函数中通过你readyState === 4 来判断是否完成， 在根据status === 200 判断是否是一个成功的响应。 XMLHttpRequest对象三个重要属性： | 属性 | 描述 | | :----- | :----- | |onreadystatechange | 每当readyState属性变化时调用的函数 | | readyState | 存有XMLHttpRequest的状态， 从0 到 4 变化 | | status | 两个值200 404 | 0： 请求未初始化 1： 服务器连接已建立 2： 请求已接收 3： 请求处理中 4： 请求已完成，且响应就绪 200： “OK” 404: 未找到页面 如果需要将请求发送到服务器，要使用XMLHttpRequest对象的open()和send()方法 - open(methon, url, async) 方法规定了请求的类型，URL，和是否异步 XMLHttpRequest对象的open()方法有三个参数，第一个参数指定是GET还是POST， 第二个参数指定URL地址， 第三个参数指定是否使用异步，默认为true, 所以不写 Async = true时才有onreadystatechange函数，为false时直接把代码放到send()方法后即可（参考W3AJAX） GET和POST的区别：与POST相比， GET更简单也更快，并且在大多数下都能用，例外在以下场景用POST： 1. 无法使用缓存文件 2. 向服务器发送大量数据（POST没有数据量 限制） 3. 发送包含未知字符的用户输入时， POST比GET更稳定和更可靠 - send(string) 将请求发送到服务器， string仅用于POST请求 服务器响应获得服务器的响应，使用XMLHttpRequest对象的responseText和responseXML属性 | 属性 | 描述 | | :----- | :----- | | responseText | 获得字符串形式的响应数据 | | responseXML | 获得XML形式的响应数据 | 安全限制由于浏览器的同源策略，JS在发送AJAX请求时，URL的域名必须和当前的页面完全一致：域名要一致，协议要相同(http和https不同), 端口号要相同 JS有大致三种方式去请求域外的URL 1. 通过Flash插件发送HTTP请求，已经快被淘汰 2. 在同源域名下架设一个代理服务器进行转发，JS负责把请求发送到代理服务器，代理服务器再把结果返回，这样就遵循了同源策略。 3. JSONP利用了浏览器允许跨域引用JS资源，限制是只能使用GET请求，并且要求返回JS。 具体的做法就是： 先在页面中准备好回调函数，然后给页面添加一个&lt;script&gt;节点，相当于动态的读取域外的JS资源 H5的跨域策略： CORSCORS全称： Cross-Origin Resourse Sharing 跨域资源共享 Origin表示当前页面的域，当JS想域外发起请求时，浏览器收到响应后，首先检查Access-Control-Allow-Origin 是否包含本域。 &gt; 用一个图来表示就是： 假设本域是my.com，外域是sina.com，只要响应头Access-Control-Allow-Origin为http://my.com，或者是*，本次请求就可以成功。 canvasCanvas时HTML5的新增组件， 他就像一个画布，可以用JS在上面绘制各种图表，动画等 PromisePromise对象是一种“承诺将来会执行”的对象。 可见Promise最大的好处是在异步执行的流程中，把执行代码和处理结果的代码清晰地分离了：]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[廖雪峰JS学习笔记]]></title>
      <url>%2F2017%2F08%2F04%2FJS_Liao-1%2F</url>
      <content type="text"><![CDATA[JavaScript 发展历程：1.网景公司95年发布JavaScript 2.ECMAScript 是标准，JavaScript是具体实现 3.ES6 15年六月发布 快速入门1.将代码放到网页的任何地方，用&lt;script&gt; … &lt;/script&gt;包含JavaScript的代码 2.将JS代码放在单独的JS文件中，&lt;script src=“”&gt; … &lt;/script&gt;引入文件 3.JS区分大小写 数据类型和变量number；字符串：’abc’ “abc”;布尔值；&amp;&amp; ；||；！； 1.== 和=== ；==会先进行数据类型的转换，===数据类型不同直接返回false，尽量使用=== 2.NaN与所有值都不相等，包括他自己 NaN === NaN; //false isNaN(NaN); //true 3.浮点数的比较，通过差值的绝对值小于某个阀值 4.null和undefined 5.数组，对象，变量：变量名是大小写英文、数字、$和_的组合，且不能用数字开头。变量名也不能是JavaScript的关键字，如if、while等。 6.不用var申明的都是全局变量，var申明的是局部变量，范围别限制在该变量神明的函数题内 7.使用严格模式：’use strict’ 字符串1.转义符\：\n表示换行，\t表示制表符，\\表示\自身 ASCII字符用\x##形式的十六进制表示 ‘\x41’ //等同于’A’ Unicode字符用\u###表示： ‘\u4e2d\u6587’ //等同于’中文’ 2.多行字符串用\n表示费事，ES6新的字符串的表示方法： 反引号` … `表示 3.使用+比较麻烦，ES6新增模板字符串，表示方法和上边一样，用` … `包起来 如： var message = `你好, ${name}, 你今年${age}岁了!`; 字符串的操作：var s = “Hello World!”;详见’JS字符串操作’文档 1.s.length取长度,s[0];//‘h’,需要注意的是，字符串是不可变的，如果对字符串的某个索引赋值，不会产生错误但是也不会产生结果 2.JavaScript为字符串提供了一些常用方法，注意，调用这些方法本身不会改变原有字符串的内容，而是返回一个新字符串： * toUpperCase()把一个字符串全部转换成大写； * toLowerCase()把一个字符串全部转换成小写； * indexOf(str)从首位检索指定字符串出现的位置；没有返回-1 * lastIndexOf(str)从末尾检索指定字符串出现的位置；没有返回-1 * substring(start, end)返回指定索引区间的子串； * slice(start, end)提取一个字符串的一部分，返回新的字符串； * substr(start, length)返回字符串的一个子串； * split(“”)将一个字符串转换成一个字符串数组； * concat(str)将两个或多个字符的文本组合起来，返回新的字符串； * charAt(index)返回指定位置的字符： a = ‘hello’; var get_char = a.charAt(0); //get_char = ‘h’; * match(正则表达式)检查以恶搞字符串匹配一个正表达式内容，没有匹配返回null 数组1. 数组长度length 2. 数组搜索：indexOf()返回元素的索引（位置） 3. 数组截取：slice(start, end)对应string的substring，可以没有任何参数，相对于复制了数组 4. push()向数组的末尾添加若干元素，pop()删除数组的最后一个元素； 5. unshift()向数组的头部添加若干元素，shift()将数组的第一个元素删除； 6. sort()对当前数组排序，按照默认顺序排序； 7. reverse()反转数组元素； 8. splice()方法是修改数组的万能方法，它可以从指定索引删除若干元素，然后再从改位置添加若干元素 12345678910var arr = [&apos;Microsoft&apos;, &apos;Apple&apos;, &apos;Yahoo&apos;, &apos;AOL&apos;, &apos;Excite&apos;, &apos;Oracle&apos;];// 从索引2开始删除3个元素,然后再添加两个元素:arr.splice(2, 3, &apos;Google&apos;, &apos;Facebook&apos;); // 返回删除的元素 [&apos;Yahoo&apos;, &apos;AOL&apos;, &apos;Excite&apos;]arr; // [&apos;Microsoft&apos;, &apos;Apple&apos;, &apos;Google&apos;, &apos;Facebook&apos;, &apos;Oracle&apos;]// 只删除,不添加:arr.splice(2, 2); // [&apos;Google&apos;, &apos;Facebook&apos;]arr; // [&apos;Microsoft&apos;, &apos;Apple&apos;, &apos;Oracle&apos;]// 只添加,不删除:arr.splice(2, 0, &apos;Google&apos;, &apos;Facebook&apos;); // 返回[],因为没有删除任何元素arr; // [&apos;Microsoft&apos;, &apos;Apple&apos;, &apos;Google&apos;, &apos;Facebook&apos;, ‘Oracle’] 9. concat([other array])把当前数组和另一个数组链接起来，并返回新的数组 10. join(‘-’)把数组当前的元素都用指定的字符串链接起来，并且返回连接后的字符串，array中元素不是字符串，会先进行转换 对象1. JS对象是一种无序的集合数据类型，由若干键值对组成 2. 属性的访问，.或者[‘’]或者[“”]，没有的属性返回undefined 3. JS对象是动态类型，可以给对象添加或者删除属性 4. 检测对象是否拥有某一属性，可以用in操作符，但是in判断属性会检查对象的父类，有可能是对象继承而来的属性 5. 判断一个属性是否是对象本身拥有，使用hasOwnProperty()方法 判断条件1.if{ …. } else{ …. } 2.JS把null，undefined，0，NaN和空字符串’’视为false，其他一律为true 循环1. for(初始条件;判断条件;递增条件){ … }，for循环常用来利用索引遍历数组 2. for … in循环，把一个对象的所有属性依此循环出来，要过滤掉对象继承的属性，使用hasOwnProperty()来实现 for … in 对数组循环得到的是String而不是Number 3. while(){ … }; do{ … }while(); Map和Set1. Map是一组键值对的结构，具有极快的查找速度 map的方法有get()和set(); 2. Set和Map类似，也是一组key的集合，但不存储value。在Set中没有重复的key。重复元素在Set中被自动过滤。 add(key)方法可以向Set中添加元素，可以重复添加，但是没有效果。 delete(key)方法删除元素。 iterable1. Array，Map，Set都属于iterable类型 2. iterable类型集合可以通过for...of循环来遍历 for … of 与for … in的区别： for ... in循环由于历史遗留问题，它遍历的实际上是对象的属性名称。一个Array数组实际上也是一个对象，它的每个元素的索引被视为一个属性 var a = [&apos;A&apos;, &apos;B&apos;, &apos;C&apos;]; a.name = &apos;Hello&apos;; for (var x in a) { alert(x); // &apos;0&apos;, &apos;1&apos;, &apos;2&apos;, &apos;name&apos; } for ... in循环将把name包括在内，但Array的length属性却不包括在内。 for ... of循环则完全修复了这些问题，它只循环集合本身的元素： var a = [&apos;A&apos;, &apos;B&apos;, &apos;C&apos;]; a.name = &apos;Hello&apos;; for (var x of a) { alert(x); // &apos;A&apos;, &apos;B&apos;, &apos;C&apos; } 3. iterable 的内置forEach()方法，它接受一个函数，每次迭代久自动回调该函数。 for example： var a = [‘a’, ‘b’, ‘c’]; a.forEach(function(element, index, array)){ //element: 指向当前元素的值 //index: 指向当前索引 //array: 指向Array对象本身 alert(element); } Set没有索引，因此回调函数的前两个参数都是元素本身 s.forEach(function(element, sameElement, set){ … }); Map的回调函数参数依次是value，key, 和map本身 m.forEach(function(value, key, map){ … }); 函数1. JS中的函数是头等公民，具有强大的抽象能力 2. 函数的定义 function abc(){ if(x&gt;=0){ return x; } else return -x; } • function指出这是一个函数定义； • abs是函数的名称； • (x)括号内列出函数的参数，多个参数以,分隔； • { ... }之间的代码是函数体，可以包含若干语句，甚至可以没有任何语句。 JS 函数也是对象，因此abc()函数实际上是一个函数对象，函数名可以看成指向该函数的变量 var abc = function(x){ … };与上边的等价 3.函数的调用abc(90); abc(); abc(1,90,x); 4.arguments只在函数的内部起作用，并且永远指向当前函数的调用者传入的所有参数。 变量作用域1. 在函数内部声明的变量，该变量的作用域为整个函数体，函数体外不可引用该变量 2. 不同函数内部的同名变量相互独立，互不影响 3. 在嵌套函数中，内部函数可以访问外部函数的变量，反过来不行 4. 函数在查找变量是从自身函数开始，由内向外查找，如果函数内部定义了与外部函数同名的变量，内部函数的变量将屏蔽外部函数的变量 5. 变量提升：把所有声明的变量提升到函数顶部，JS引擎提升变量的声明，但是不会提升变量的赋值。 因此在JS中，请严格遵守“在函数内部首先声明所有的变量”这一规则，常用的方法是用 一个var申明函数内部用到的所有变量 全局作用域1. 不在任何函数内定义的变量就具有全局作用域，JS有一个默认的全局对象Window，全局作用域的变量实际上被绑定到window的一个属性 2. 顶层函数的定义被视为一个全局变量，并绑定到window对象 3. JS实际上只有一个全局作用域，任何变量（函数也视为是变量），如果在当前作用域中没有找到，就会继续向上查找。在全局作用域也没找到，则报ReferenceError错误。 名字空间1. 全局变量会绑定到window上，不同JS文件如果使用了相同的全局变量，就会造成命名冲突。 2. 减少冲突的方法是把自己的所有变量和函数全部绑定到一个全局变量中 局部作用域1.JS变量的作用域是函数内部，因此在for循环等语句块无法定义具有局部作用域的变量 2.为了解决块级作用域，ES6引入关键字let，用let可以声明一个块级作用域的变量 常量1.在ES6之前用大写的变量表示这是一个变量 2.ES6引入新的关键字const定义变量，const与let都具有块级作用域 方法1. 方法其实就是函数，但是一般称绑定在对象上的函数称为方法 2. 在方法内部，this是一个特殊变量，指向对前对象，就是方法绑定的那个对象 3. 以对象的方法形式调用，函数的this指向被调用的对象，如果单独调用，this指向全局变量即window。在strict模式下，this指向undefined的，因此在strict模式下，会得到一个 错误 12345678910111213&apos;use strict&apos;;var xiaoming = &#123; name: &apos;小明&apos;, birth: 1990, age: function () &#123; function getAgeFromBirth() &#123; var y = new Date().getFullYear(); return y - this.birth; &#125; return getAgeFromBirth(); &#125;&#125;; xiaoming.age(); // Uncaught TypeError: Cannot read property &apos;birth&apos; of undefined 结果又报错了！原因是this指针只在age方法的函数内指向xiaoming，在函数内部定义的函数，this又指向undefined了！（在非strict模式下，它重新指向全局对象window！） 修复的办法也不是没有，我们用一个that变量首先捕获this： apply1. 在单独的函数调用时，this指向window或者undefined，不过我们可以控制this的指向 2. 调用函数的apply方法，指定函数的this指向。apply接受两个参数，第一个参数是需要绑定的this变量，第二个参数是Array，表示函数本身的参数getAge.apply(xiaoming, []); 3. call()跟apply一样，只是apply把参数打包成Array再传入，call()把参数顺序传入 4. 对普通函数的调用，我们可以把this绑定为null 装饰器1. 利用apply()，可以动态改变函数的行为 高阶函数1. 高阶函数：higher-order function。函数可以接受另一个函数作为参数，这样的函数就是高阶函数，下边的都是一些高阶函数 2. map()方法，map()方法定义在JS的Array中，我们调用Array的map()方法，传入我们自己的函数，就得到一个新的Array作为结果。对数组中每一个元素调用我们的方法 3. reduce()方法，Array的reduce()方法把一个函数作用在Array的[x1,x2,x3..]上，这个函数必须接受两个参数，reduce()把结果和序列的下一个元素做累积计算。 4. filter()方法，Array的filter()方法接受一个“筛选”函数，把该函数作用与数组的每个元素，然后根据返回值的true和false决定保留还是丢弃该元素。filter()接受回调函数，可以有多个参数，第一个元素表示Array的某个元素，第二个参数表示元素的位置，第三个表示数组本身 5. sort()方法，数组的sort()方法默认把所有元素转化成String，然后在排序。sort()也是高阶函数，它可以接受一个比较函数来实现自定义排序。忽略大小比较字符串，要将字符串都变成小写或者大写。sort()方法直接对Array进行修改。 闭包1. 高阶函数除了可以接受函数参数外，还可以将函数作为结果返回。 2. 返回闭包时牢记返回函数不要引用任何循环变量，或者后续会发生变化的变量 3. 创建一个匿名函数并立即执行 (function(x){return x * x;}) (3); 4. 闭包就是携带状态的函数，并且他的状态完全对外隐藏 箭头函数1. 箭头函数相当于匿名函数，（参数）=&gt; { 函数体 } 2. 当只有一个函数参数跟一条语句时简写为 x =&gt; x*x; return 都可以省略 如果想要返回一个对象，函数体的{}跟对象的{}有冲突，可以用()扩起来： x =&gt; ({foo: x }) 3. 箭头函数与匿名函数的区别，箭头函数内部的this是词法作用域，由上下文确定 4. 由于this在箭头函数中已经按照词法作用域绑定了， 所以用call()和apply() 调用箭头函数时，无法用this进行绑定。即第一个传入的参数将被忽略。 generator1. generator(生成器)时ES6引入的新的数据类型，看上去是一个函数，但是可以返回多次。 2. generator和函数的不同是：generator由function* (注意*)定义，除了return语句，还可以用yield返回多次。 3. 直接调用generator，仅仅是创建了一个generator对象，而没去执行它，调用generator对象有两个方法： 一个是不断的调用generator对象的next()方法，next方法会执行generator的代码，然后每次遇到yield x; 就会返回一个对象{value: x, done: true/false},value就是yield的返回值，done表示这个generator是否执行结束。如果done为true，value就是return的返回值。 一个是直接调用for … of 循环迭代generator对象，这种方式不需要自己判断done 4.generator看上去是一个可以记住状态的函数，generator可以写出需要面向对象才能实现的功能，generator就是把异步回调变成同步代码 标准对象1. 在JS世界中，一切都是对象，为了区别对象的类型，用typeof操作符获取对象的类型，他总是返回一个字符串。null 和array的类型也是object，使用typeof无法区分出null，Array和通常意义上的对象{} 2. 包装对象 遵守： • 不要使用new Number()、new Boolean()、new String()创建包装对象； • 用parseInt()或parseFloat()来转换任意类型到number； • 用String()来转换任意类型到string，或者直接调用某个对象的toString()方法； • 通常不必把任意类型转换为boolean再判断，因为可以直接写if (myVar) {...}； • typeof操作符可以判断出number、boolean、string、function和undefined； • 判断Array要使用Array.isArray(arr)； • 判断null请使用myVar === null； • 判断某个全局变量是否存在用typeof window.myVar === &apos;undefined&apos;； • 函数内部判断某个变量是否存在用typeof myVar === &apos;undefined&apos;。 ** 任何对象都有toString()方法吗？null和undefined就没有！确实如此，这两个特殊值要除外，虽然null还伪装成了object类型。 ** Number对象调用toString()报错，123.toString(); // 错误 正确的： 123..toString(); 或者 (123).toString(); Date1.要获取系统当前时间，用var now = new Date(); 可以使用now.getFullYear();获得月份；使用now.getMonth();获得月份等等 2.当前时间是浏览器从本机的操作系统获取的时间，因此不一定准确。创建一个指定日期：var d = new Date(2015, 5, 19, 20, 15, 30, 123); 3.在JS中，0表示一月份，一次类推。 RegExp 正则表达式- \d 匹配一个数字， \w匹配一个字符或者数字 - . 匹配任意一个字符 - * 表示任意个字符（包括0个），+ 表示至少一个字符， ？表示0个或者1个字符， {n} 表示n个字符，{n,m} 表示n-m个字符 - \s匹配一个空格（也包括Tab等空格符） - A|B 可以匹配A也可以匹配B - ^ 表示行的开头，$表示行的结束 ^\d 表以数字开头 \d$表示以数字结尾 - []表示范围 [0-9a-zA-Z\_]可以匹配一个数字字符或者下划线 javaScript中正则表达式的创建 1. ／正则表达式／ 2. new RegExp(‘正则表达式’) RegExp对象的test() 方法用于测试给定字符串是否符合条件 使用： 切分字符串： ‘a b c’.split(‘ ’); // [‘a’, ‘b’, ‘’, ‘’, ‘’, ‘c’] ‘a b c’.split(/\s+/); // [‘a’, ‘b’, ‘c’] ‘a,b, c d’.split(/[\s\,]+/); 分组： 正则表达式可以提取子串，用()表示要提取的分组 如：^(\d{3}) - (\d{3,8})$ 定义的组，就可以再RegExp对象上用exec()方法提取子串 exec()方法匹配成功后，会返回一个Array，第一个元素是匹配到的整个字符串，后边的字符串表示匹配成功的子串 3. 贪婪匹配： \d+ 贪婪匹配 \d? 非贪婪匹配 4. 全局搜索 g 表示全局匹配 I 表示忽略大小写 m 表示多行匹配 JSONJSON的字符集必须是UTF-8，JSON必须用双引号“” 1. 将JS对象序列化成JSON格式的字符串： JSON.stringify(obj, null, ‘ ‘); 第二个参数用于控制筛选对象的键值，只输出制定的属性， 可以传入Array： JSON.stringify(obj, [‘name’, ‘skill’], ‘’); 也可以传入一个函数，对象的每个键值对都被函数先处理 可以将一个JSON对象添加一个toJSON方法，直接返回JSON应该序列化的数据 2. 反序列化 JSON.parse()将JSON格式的字符串变成JS对象 JSON.parse(‘{“name”: “小明”, “age”:14}’, function(key, value) { 用来解析属性}) 面向对象obj._proto_改变对象的原型 Object.create()方法可以传入一个原型对象，并创建一个基于该原型的新对象 1. 创建对象 JS对每个创建的对象设置一个原型，只想他的原型对象 arr—-&gt; Array.prototype —-&gt; Object.prototype —-&gt; null 2. 构造函数 定义一个函数，通过new 关键字来调用这个函数，并默认返回this 通过new Student()创建的对象还从原型上获得一个constructor属性， 它指向函数Student本身 3. 原型继承 #### class继承 class从ES6引入 class Student(name) { constructor(name) { this.name = name; } hello() { alert(‘Hello’); } }]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[图片模糊和灰度处理，边界检测]]></title>
      <url>%2F2017%2F05%2F31%2FBlurImage%2F</url>
      <content type="text"><![CDATA[图像卷积和滤波的一些知识滤波过程：对图像的每一个像素点，计算他邻域的像素和滤波器矩阵（卷积核）的对应元素的乘积，然后加起来作为该点的像素值卷积和协相关： 对图像和滤波矩阵进行逐个的元素相乘再求和的操作就相当于将一个二维函数转移到另一个二维函数的所有位置，这个操作就是卷积或者协相关 区别： 卷积要先对滤波矩阵进行180的翻转 滤波器的规则： 滤波器大小为奇数，有中心有半径： 如3X3，5X5 滤波器所有元素之和为1，保证图片亮度不变。&gt;1 更亮，&lt;1 变暗 出现负数和大于255直接截断或者取绝对值 图像知识：一个图片有宽高，在屏幕上他的宽高分别代表了宽多少个像素，高有多少个像素，一个像素点有四个值：r,g,b,a。那么遍历图像的所有像素有：```for (let i = 0; i &lt; picture.width; i++) { for (let j = 0; j &lt; picture.height; j++) { let k = (j width + i) 4; pixes[k] // r pixes[k+1] // g pixes[k+2] // b pixes[k+3] // a }} 高斯模糊：实例：1.高斯模糊]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[第四章CSS3使用]]></title>
      <url>%2F2017%2F03%2F25%2FHTML5-CSS-4%2F</url>
      <content type="text"><![CDATA[HTML5和CSS3学习笔记CSS特性： 特性 用法 nth-of-type [p:nth-of-type(2n+1){color: red;}] first-child [p:first-child{color:blue;}] nth-child [p:nth-child(2n+1){color:red}] last-child [p:last-child{color:blue;}] nth-last-child [p:nth-last-child(2n+1){color:red}] first-of-type [p:first-of-type{color:blue}] last-of-type [p:last-of-type{color:blue}] after 与content一起使用，在指定元素后加内容 对列的支持 将内容区域分成多列 媒体查询 基于设备设置应用样式 多列布局1234567891011\#content&#123; column-count: 2; -moz-column-count: 2; -webkit-column-count: 2; column-gap: 20px; -moz-column-gap: 20px; -webkit-column-gap: 20px; column-rule: 1px solid #ddccb5; -moz-column-rule: 1px solid #ddccb5; -webkit-column-rule: 1px solid #ddccb5;&#125; 媒体查询CSS3的媒体查询允许开发人员根据方可的屏幕尺寸大小来调整整个页面的渲染效果，媒体查询可以查询一下内容：分辨率，方向，设备的宽高，浏览器窗口的宽高 如：在样式表结束添加：123456789@media only screen and (max-device-width: 480px) &#123; body&#123; width: 460px; &#125; section#sidebar, section#posts&#123; float: none; width: 100%; &#125;&#125; 也可以在关联样式表时，使用媒体查询，然后将移动设备的样式表放入单独的文件中1&lt;link rel = &quot;stylesheet&quot; type = &quot;text/css&quot; href = &quot;CSS/monile.css&quot; media = &quot;only screen and (max-device-width: 480px)&quot;&gt; 实例：1.优化的付款清单]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[第三章创建易用的web表单]]></title>
      <url>%2F2017%2F03%2F21%2FHTML5-CSS-3%2F</url>
      <content type="text"><![CDATA[HTML5和CSS3学习笔记常用的表单输入域： 类型 用法 &lt;input type=”email”&gt; 显示一个输入邮件地址的表单域 &lt;input type=”url”&gt; 显示一个输入URL的表单域 &lt;input type=”tel”&gt; 显示一个输入电话号码的表单域 &lt;input type=”search”&gt; 显示一个输入搜索关键字的表单域 &lt;input type=”range”&gt; 显示一个滑块组件 &lt;input type=”number”&gt; 显示一个输入数值的表单域 &lt;input type=”date”&gt; 显示用于日期选择的表单域 &lt;input type=”datetime”&gt; 显示用于日期选择和时间选择的表单域 &lt;input type=”text” autofocus&gt; 支持将焦点置于特定的表单元素上 &lt;input type=”email” placeholder=”me@example.com”&gt; 在表单中显示占位文本 &lt;p contenteditable&gt;lorem ipsum&lt;/p&gt; 支持通过浏览器在位编辑内容 实例 实例1 基础表单 实例2 注册表单(含有动态验证码)]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[第二章新的结构标签和属性]]></title>
      <url>%2F2017%2F03%2F18%2FHTML5-CSS-2%2F</url>
      <content type="text"><![CDATA[HTML5和CSS3学习笔记1.新的结构标签和属性 结构标签 用法 &lt;header&gt; 定义页面或区段的头部 &lt;footer&gt; 定义页面或者区段的尾部 &lt;nav&gt; 定义页面或者区段的导航区域 &lt;section&gt; 定义页面的逻辑区域或内容组合 &lt;article&gt; 定义正文或一片完整的内容 &lt;aside&gt; 定义补充或相关内容 &lt;meter&gt; 描述指定范围内的数值 &lt;progress&gt; 用于显示实时进度的控件 自定义的数据属性 允许通过“data-”前缀向任意元素中添加自定义的数据属性 2.实例：用语义化标记重新定义博客12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;title&gt;&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;header id=&quot;page_header&quot;&gt; &lt;h1&gt;Hello World!&lt;/h1&gt; &lt;nav&gt; &lt;ul&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;Home&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;Articles&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;About me&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;Contact me&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/nav&gt; &lt;/header&gt; &lt;section id=&quot;posts&quot;&gt; &lt;article class=&quot;post&quot;&gt; &lt;header id=&quot;section_header&quot;&gt; &lt;h2&gt;Welcome to my blog!&lt;/h2&gt; &lt;p&gt;Posted by GuoRuiyang on &lt;time datetime=&quot;2017-03-18T16:27&quot;&gt;March 18st, 2017 at 4:27PM&lt;/time&gt;&lt;/p&gt; &lt;/header&gt; &lt;aside&gt; &lt;p&gt;&amp;quot;Never give someone a chance to say no when you selling your product.&amp;quot;&lt;/p&gt; &lt;/aside&gt; &lt;P&gt; Life is full of confusing and disordering Particular time,a particular location,Do the arranged thing of ten million time in the brain,Step by step ,the life is hard to avoid delicacy and stiffness No enthusiasm forever,No unexpected happening of surprising and pleasing So,only silently ask myself in mind Next happiness,when will come? &lt;P&gt; &lt;P&gt; Then the wandering soul wild crane stands still the memory river Listen to whistle play tightly ring slowly,Water rises a ship to go medium long things of the past.Wait for a ship’s person Wait for one and other,But hesitate always should ascend which ship Missed Had to consign the hope to next time,Finally what to wait for until has no boats and ships to come and go,Sunset west . &lt;/P&gt; &lt;footer id=&quot;article_footer&quot;&gt;&lt;p&gt;&lt;a href=&quot;#&quot;&gt;&lt;i&gt;25 comments&lt;/i&gt;&lt;/a&gt;.....&lt;/p&gt;&lt;/footer&gt; &lt;/article&gt; &lt;footer&gt;&lt;/footer&gt; &lt;/section&gt; &lt;section id=&quot;sidebar&quot;&gt; &lt;header&gt;&lt;h3&gt;Archives&lt;/h3&gt;&lt;/header&gt; &lt;nav&gt; &lt;ul&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;Home&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;Articles&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;About me&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;Contact me&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/nav&gt; &lt;/section&gt; &lt;footer id=&quot;page_footer&quot;&gt; &lt;p&gt;@copy;2017GuoRuiyang.&lt;/p&gt; &lt;ul&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;Home&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;Articles&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;About me&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=&quot;#&quot;&gt;Contact me&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/footer&gt;&lt;/body&gt;&lt;/html&gt;]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Hello World]]></title>
      <url>%2F2017%2F03%2F15%2Fhello-world%2F</url>
      <content type="text"><![CDATA[欢迎来到我的博客，在我花费了（牺牲了）我两个晚上的打游戏的时间，把自己的博客网站给搭建起来了。我是一名程序猿，所以从Hello World!开始。我的博客里会更新自己的一些学习笔记和一些原创的个人文章，希望给大家呢带来知识和快乐。技术文章转载希望能够注明转载，同样我也会注明自己的转载。 &gt; 如果智慧与美貌不能并存，那我算什么。 *沃.兹季硕德*]]></content>
    </entry>

    
  
  
</search>
